/*
 * /*
The code in this plugin was written using shared resources from several places.  
I include their license information and links to the sites from which the shared code was accessed.
https://github.com/openmicroscopy/bioformats/blob/develop/components/formats-gpl/utils/PrintTimestamps.java
https://albert.rierol.net/imagej_programming_tutorials.html

 * #%L
 * OME Bio-Formats package for reading and converting biological file formats.
 * %%
 * Copyright (C) 2005 - 2016 Open Microscopy Environment:
 *   - Board of Regents of the University of Wisconsin-Madison
 *   - Glencoe Software, Inc.
 *   - University of Dundee
 * %%
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of the 
 * License, or (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public 
 * License along with this program.  If not, see
 * <http://www.gnu.org/licenses/gpl-2.0.html>.
 * #L%
 */

/**
 *
 * @author pattersg
 */

import ij.*;
import ij.io.*;
import ij.gui.*;
import ij.process.*;
import ij.measure.*;
import java.awt.*;
import java.io.IOException;
import ij.util.Tools;
import java.awt.event.*;
import java.io.File;


import loci.formats.FormatException;
import loci.formats.IFormatReader;
import loci.plugins.*;

import java.util.logging.Level;
import java.util.logging.Logger;

import loci.common.services.ServiceFactory;
import loci.formats.ImageReader;
import loci.formats.meta.IMetadata;
import loci.formats.services.OMEXMLService;

import ome.units.quantity.Time;
import ome.units.UNITS;



public class Pixel_Fitter extends javax.swing.JFrame implements MouseListener, MouseMotionListener, Measurements, KeyListener {

    int imageH;
    int imageW;
    int imageD;
    int imageZ;
    int imageF;
    int numCycles;
    int imagesPerCycle;
    double R2CutOff;
    double[] timeData;
    double[] timeData3;
    double [][][] rateDataG;
    double [][][] offsetDataG;
    double [][][] aZeroDataG;
    double [][][] R2G;
    String id;
    ImagePlus img;
    ImageCanvas canvas;
    ImageCanvas canvas2;
    PlotWindow pwin;
    PlotWindow pwin2;
    public double[] yAxis;
    public double[] xAxis;
    String xLabel;
    String yLabel;
    boolean listenersRemoved;
    int xpoint, ypoint;
    ImagePlus rateConstantImage;
    ImagePlus offsetImage;
    ImagePlus aZeroImage;
    ImagePlus R2Image;
    boolean chWarnOff;
    /**
     * Creates new form NewJFrame
     */
    public Pixel_Fitter() {
        initComponents();
        setVisible(true);
     }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        FitStack = new javax.swing.JButton();
        OpenStack = new javax.swing.JButton();
        ExaminePixels = new javax.swing.JButton();
        MakeSaveFitParameterImage = new javax.swing.JButton();
        imagesPerCycleTF = new javax.swing.JFormattedTextField();
        imagesPerCycleLabel = new javax.swing.JLabel();
        numCyclesLabel = new javax.swing.JLabel();
        numCyclesTF = new javax.swing.JFormattedTextField();
        imagesPerCycleLabel1 = new javax.swing.JLabel();
        R2CutOffTF = new javax.swing.JFormattedTextField();
        makeRateConstantImage = new javax.swing.JButton();

        setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);
        setTitle("Photoswitching Pixel Fitter");

        FitStack.setText("Fit pixels with exponential");
        FitStack.setMaximumSize(new java.awt.Dimension(200, 30));
        FitStack.setMinimumSize(new java.awt.Dimension(200, 30));
        FitStack.setPreferredSize(new java.awt.Dimension(200, 30));
        FitStack.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                FitStackActionPerformed(evt);
            }
        });

        OpenStack.setText("Import with Bio-Formats");
        OpenStack.setMaximumSize(new java.awt.Dimension(200, 30));
        OpenStack.setPreferredSize(new java.awt.Dimension(200, 30));
        OpenStack.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                OpenStackActionPerformed(evt);
            }
        });

        ExaminePixels.setText("Examine pixel fits");
        ExaminePixels.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                ExaminePixelsActionPerformed(evt);
            }
        });

        MakeSaveFitParameterImage.setText("Save fit parameters");
        MakeSaveFitParameterImage.setMaximumSize(new java.awt.Dimension(200, 30));
        MakeSaveFitParameterImage.setPreferredSize(new java.awt.Dimension(200, 30));
        MakeSaveFitParameterImage.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                MakeSaveFitParameterImageActionPerformed(evt);
            }
        });

        imagesPerCycleTF.setFormatterFactory(new javax.swing.text.DefaultFormatterFactory(new javax.swing.text.NumberFormatter()));
        imagesPerCycleTF.setHorizontalAlignment(javax.swing.JTextField.RIGHT);
        imagesPerCycleTF.setText("300");
        imagesPerCycleTF.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                imagesPerCycleTFActionPerformed(evt);
            }
        });
        imagesPerCycleTF.addPropertyChangeListener(new java.beans.PropertyChangeListener() {
            public void propertyChange(java.beans.PropertyChangeEvent evt) {
                imagesPerCycleTFPropertyChange(evt);
            }
        });

        imagesPerCycleLabel.setText("Images per cycle");

        numCyclesLabel.setText("Number of cycles");

        numCyclesTF.setFormatterFactory(new javax.swing.text.DefaultFormatterFactory(new javax.swing.text.NumberFormatter(java.text.NumberFormat.getIntegerInstance())));
        numCyclesTF.setHorizontalAlignment(javax.swing.JTextField.RIGHT);
        numCyclesTF.setText("3");
        numCyclesTF.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                numCyclesTFActionPerformed(evt);
            }
        });
        numCyclesTF.addPropertyChangeListener(new java.beans.PropertyChangeListener() {
            public void propertyChange(java.beans.PropertyChangeEvent evt) {
                numCyclesTFPropertyChange(evt);
            }
        });

        imagesPerCycleLabel1.setText("R2 cutoff");

        R2CutOffTF.setHorizontalAlignment(javax.swing.JTextField.RIGHT);
        R2CutOffTF.setText("0.9");
        R2CutOffTF.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                R2CutOffTFActionPerformed(evt);
            }
        });
        R2CutOffTF.addPropertyChangeListener(new java.beans.PropertyChangeListener() {
            public void propertyChange(java.beans.PropertyChangeEvent evt) {
                R2CutOffTFPropertyChange(evt);
            }
        });

        makeRateConstantImage.setText("Remake rate constant image");
        makeRateConstantImage.setToolTipText("");
        makeRateConstantImage.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                makeRateConstantImageActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                    .addGroup(javax.swing.GroupLayout.Alignment.LEADING, layout.createSequentialGroup()
                        .addGap(59, 59, 59)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                            .addComponent(imagesPerCycleLabel1)
                            .addComponent(imagesPerCycleLabel))
                        .addGap(18, 18, 18)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(imagesPerCycleTF, javax.swing.GroupLayout.PREFERRED_SIZE, 44, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(R2CutOffTF, javax.swing.GroupLayout.PREFERRED_SIZE, 44, javax.swing.GroupLayout.PREFERRED_SIZE)))
                    .addGroup(javax.swing.GroupLayout.Alignment.LEADING, layout.createSequentialGroup()
                        .addGap(60, 60, 60)
                        .addComponent(numCyclesLabel)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(numCyclesTF, javax.swing.GroupLayout.PREFERRED_SIZE, 44, javax.swing.GroupLayout.PREFERRED_SIZE)))
                .addGap(0, 22, Short.MAX_VALUE))
            .addGroup(layout.createSequentialGroup()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                        .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                            .addComponent(FitStack, javax.swing.GroupLayout.DEFAULT_SIZE, 236, Short.MAX_VALUE)
                            .addComponent(OpenStack, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addComponent(ExaminePixels, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addComponent(MakeSaveFitParameterImage, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)))
                    .addGroup(layout.createSequentialGroup()
                        .addContainerGap()
                        .addComponent(makeRateConstantImage, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGap(21, 21, 21)
                .addComponent(OpenStack, javax.swing.GroupLayout.PREFERRED_SIZE, 35, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(30, 30, 30)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(numCyclesLabel)
                    .addComponent(numCyclesTF, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(imagesPerCycleLabel)
                    .addComponent(imagesPerCycleTF, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(imagesPerCycleLabel1, javax.swing.GroupLayout.PREFERRED_SIZE, 26, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(R2CutOffTF, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGap(27, 27, 27)
                .addComponent(FitStack, javax.swing.GroupLayout.PREFERRED_SIZE, 39, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(28, 28, 28)
                .addComponent(makeRateConstantImage)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 37, Short.MAX_VALUE)
                .addComponent(ExaminePixels, javax.swing.GroupLayout.PREFERRED_SIZE, 47, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(18, 18, 18)
                .addComponent(MakeSaveFitParameterImage, javax.swing.GroupLayout.PREFERRED_SIZE, 46, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(22, 22, 22))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    


     
    private void FitStackActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_FitStackActionPerformed
            boolean imageOpenAlready = false;
            String[] imageTitles = WindowManager.getImageTitles();
        for (String imageTitle : imageTitles) {
            if (imageTitle.contains("RateConstantsImage")) {
                imageOpenAlready = true;
            }
        }
            if(imageOpenAlready){
                IJ.showMessage("Pixel Fitter", "Please close the existing rate constants image\nSorry, I'm getting confused");
                return;
            }
            img = IJ.getImage();
            if(img.isHyperStack() && chWarnOff==false){
                GenericDialog wfc = new GenericDialog("Channel confirmations");
        	wfc.addMessage("Have you selected the channel\nyou wish to fit?");
        	wfc.addCheckbox("Do not show this warning", false);
			wfc.showDialog();
				if(wfc.wasCanceled())
					return;
                chWarnOff = wfc.getNextBoolean();
            }
            try {
                psFRET_Fit_exponential();
            } catch (Exception ex) {
                Logger.getLogger(Pixel_Fitter.class.getName()).log(Level.SEVERE, null, ex);
            }
    }//GEN-LAST:event_FitStackActionPerformed

    private void OpenStackActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_OpenStackActionPerformed
      
        OpenDialog stackIsWhere = new OpenDialog("Choose a stack to open", null);
        String dir = stackIsWhere.getDirectory(); 
        String stackToOpen = stackIsWhere.getFileName();
            id =  dir + stackToOpen;
            try {
            //IJ.run("Bio-Formats", "open="+dir+stackToOpen+" autoscale color_mode=Default rois_import=[ROI manager] view=Hyperstack stack_order=XYCZT");
            ImagePlus[] imp = BF.openImagePlus(id);
            imp[0].show();
            img = IJ.getImage();
            }
            catch (FormatException exc) {
                IJ.error("Sorry, an error occurred: " + exc.getMessage());
            } catch (IOException ex) {
                Logger.getLogger(Pixel_Fitter.class.getName()).log(Level.SEVERE, null, ex);
            }
    }//GEN-LAST:event_OpenStackActionPerformed

    private void ExaminePixelsActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_ExaminePixelsActionPerformed
        if(rateDataG==null){
            final int currentchannel = img.getC()-1;       
            final int currentZ = img.getZ()-1;
            final int nSlices = img.getNSlices();        
            int size = img.getNFrames();
                    if(size==1)//in case the stack is read as a Z stack instead of T stack
                            size = nSlices;
            try{
                    timeData3 = getTimingPerPlane(id, size, currentZ, currentchannel);
             }catch (Exception e){
                    e.printStackTrace();
            }
            setUpListeners();
        }else{
              setUpListeners();
          }
    }//GEN-LAST:event_ExaminePixelsActionPerformed



   
    private void MakeSaveFitParameterImageActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_MakeSaveFitParameterImageActionPerformed
        if(aZeroDataG==null || rateDataG==null || offsetDataG==null || R2G==null){
            IJ.showMessage("Pixel Fitter", "No fit parameter data available");
        }else{
	    String id2 = id.substring(0, id.indexOf("."));
            File f1 = new File(id2 +"_RateConstantsImage.tif");
            File f2 = new File(id2 +"_AZeroImage.tif");
            File f3 = new File(id2 +"_OffsetImage.tif");
            File f4 = new File(id2 +"_R2Image.tif.tif");
            if(f1.exists()||f2.exists()||f3.exists()||f4.exists()){
                GenericDialog gdEx = new GenericDialog("Pixel Fitter");
        	gdEx.addMessage("Analyzed results files present for this image\n "+id2);
        	gdEx.addCheckbox("Overwrite?", false);
			gdEx.showDialog();
				if(gdEx.wasCanceled())
					return;
        	boolean overWrite = gdEx.getNextBoolean();
                if(overWrite){
                    ImagePlus imp = createRateConstantImage();
                    IJ.saveAs(imp, "Tiff", id2 +"_RateConstantsImage.tif");
                    imp.close();
                    imp = createAZeroImage();
                    IJ.saveAs(imp, "Tiff", id2 +"_AZeroImage.tif");
                    imp.close();
                    imp = createOffsetImage();
                    IJ.saveAs(imp, "Tiff", id2 +"_OffsetImage.tif");
                    imp.close();
                    imp = createR2Image();
                    IJ.saveAs(imp, "Tiff", id2 +"_R2Image.tif");
                    imp.close();
                }
            }else{
            ImagePlus imp = createRateConstantImage();
            IJ.saveAs(imp, "Tiff", id2 +"_RateConstantsImage.tif");
            imp.close();
            imp = createAZeroImage();
            IJ.saveAs(imp, "Tiff", id2 +"_AZeroImage.tif");
            imp.close();
            imp = createOffsetImage();
            IJ.saveAs(imp, "Tiff", id2 +"_OffsetImage.tif");
            imp.close();
            imp = createR2Image();
            IJ.saveAs(imp, "Tiff", id2 +"_R2Image.tif");
            imp.close();
            }
        }
    }//GEN-LAST:event_MakeSaveFitParameterImageActionPerformed

    private void imagesPerCycleTFActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_imagesPerCycleTFActionPerformed
        try{
            imagesPerCycle = Integer.parseInt(imagesPerCycleTF.getText());
        } catch (NumberFormatException e) {
            e.printStackTrace();
        }
    }//GEN-LAST:event_imagesPerCycleTFActionPerformed

    private void numCyclesTFActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_numCyclesTFActionPerformed
        try{
            numCycles = Integer.parseInt(numCyclesTF.getText());
        } catch (NumberFormatException e) {
            e.printStackTrace();
        }
    }//GEN-LAST:event_numCyclesTFActionPerformed

    private void imagesPerCycleTFPropertyChange(java.beans.PropertyChangeEvent evt) {//GEN-FIRST:event_imagesPerCycleTFPropertyChange
        try{
            imagesPerCycle = Integer.parseInt(imagesPerCycleTF.getText());
        } catch (NumberFormatException e) {
            e.printStackTrace();
        }
    }//GEN-LAST:event_imagesPerCycleTFPropertyChange

    private void numCyclesTFPropertyChange(java.beans.PropertyChangeEvent evt) {//GEN-FIRST:event_numCyclesTFPropertyChange
        try{
            numCycles = Integer.parseInt(numCyclesTF.getText());
        } catch (NumberFormatException e) {
            e.printStackTrace();
        }
    }//GEN-LAST:event_numCyclesTFPropertyChange

    private void R2CutOffTFActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_R2CutOffTFActionPerformed
        try{
            R2CutOff = Double.parseDouble(R2CutOffTF.getText());
        } catch (NumberFormatException e) {
            e.printStackTrace();
        }
    }//GEN-LAST:event_R2CutOffTFActionPerformed

    private void R2CutOffTFPropertyChange(java.beans.PropertyChangeEvent evt) {//GEN-FIRST:event_R2CutOffTFPropertyChange
        try{
            R2CutOff = Double.parseDouble(R2CutOffTF.getText());
        } catch (NumberFormatException e) {
            e.printStackTrace();
        }
    }//GEN-LAST:event_R2CutOffTFPropertyChange

    private void makeRateConstantImageActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_makeRateConstantImageActionPerformed
        if(rateDataG==null){
            IJ.showMessage("Pixel Fitter", "No rate constant data available");
        }else{
            boolean imageOpenAlready = false;
            String[] imageTitles = WindowManager.getImageTitles();
            for (String imageTitle : imageTitles) {
                if (imageTitle.contains("RateConstantsImage")) {
                    imageOpenAlready = true;
                }
            }
            if(!imageOpenAlready)
                rateConstantImage = createRateConstantImage();
        }
    }//GEN-LAST:event_makeRateConstantImageActionPerformed

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(Pixel_Fitter.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(Pixel_Fitter.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(Pixel_Fitter.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(Pixel_Fitter.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            @Override
            public void run() {
                new Pixel_Fitter().setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton ExaminePixels;
    private javax.swing.JButton FitStack;
    private javax.swing.JButton MakeSaveFitParameterImage;
    private javax.swing.JButton OpenStack;
    private javax.swing.JFormattedTextField R2CutOffTF;
    private javax.swing.JLabel imagesPerCycleLabel;
    private javax.swing.JLabel imagesPerCycleLabel1;
    private javax.swing.JFormattedTextField imagesPerCycleTF;
    private javax.swing.JButton makeRateConstantImage;
    private javax.swing.JLabel numCyclesLabel;
    private javax.swing.JFormattedTextField numCyclesTF;
    // End of variables declaration//GEN-END:variables


public void psFRET_Fit_exponential() throws Exception {//implements PlugIn {
        
        img = IJ.getImage();
        IJ.resetMinAndMax(img);
        //in case the image is opened without using the plugin BioFormats button
        String dir0 = IJ.getDirectory("image"); 
        String stackToOpen = img.getTitle();
        String id2 =  dir0 + stackToOpen;
        String fExt = id2.substring(id2.indexOf("."), id2.length());
	    if(fExt.contains(" ") && fExt.indexOf(" ")<id2.length())
	    	fExt = fExt.substring(0, fExt.indexOf(" "));
        id = id2.substring(0, id2.indexOf("."))+fExt;        
        
        final ImageStack img2 = img.getStack();
        imageH = img2.getHeight();
        imageW = img2.getWidth();
        imageD = img2.getBitDepth();
        imageZ = img2.getSize();
        final int currentchannel = img.getC()-1;       
        final int currentZ = img.getZ()-1;
        final int nSlices = img.getNSlices();        
        int size = img.getNFrames();
		if(size==1)//in case the stack is read as a Z stack instead of T stack
			size = nSlices;
        if(numCycles*imagesPerCycle > size){
            IJ.showMessage("Pixel Fitter", "The number of cycles multiplied by the number images per cycle is larger than the stack");
            return;
        }
	try{
        	timeData3 = getTimingPerPlane(id, size, currentZ, currentchannel);
         }catch (Exception e){
        	e.printStackTrace();
        }
            rateDataG= new double[imageW][imageH][numCycles];
            offsetDataG= new double[imageW][imageH][numCycles];
            aZeroDataG= new double[imageW][imageH][numCycles];
            R2G= new double[imageW][imageH][numCycles];

        for (int cycle = 0; cycle < numCycles; cycle++) {
            double[] timeData2 = new double[imagesPerCycle];
            for (int k = 0; k < imagesPerCycle; k++) {
                timeData2[k] = (timeData3[k + (cycle * imagesPerCycle)] - timeData3[cycle * imagesPerCycle]);
            }
            timeData = timeData2;
             //final double[][][] residualsStack = new double[imageW][imageH][timeData.length];
            //final double[][][] fitStack = new double[imageW][imageH][timeData.length];
                     
            final Thread[] threads = newThreadArray();
            //IJ.log("number of threads= " + threads.length);
            final double[][] timeDataArrayOfArrays = new double[threads.length][timeData.length];
            final double[][] pixelsArrayOfArrays = new double[threads.length][timeData.length];

            for (int ithread = 0; ithread < threads.length; ithread++) {
                final int threadIndex = ithread;
                final int cycleNum = cycle;
                final int height = imageH;
                final int width = imageW;
                // Concurrently run in as many threads as CPUs  
                threads[ithread] = new Thread() {
                    {
                        setPriority(Thread.NORM_PRIORITY);
                    }
                    @Override
                    public void run() {
                        for (int y = threadIndex * height / threads.length; y < (threadIndex + 1) * height / threads.length; y++) {                        	
                            if(threadIndex==threads.length-1){
                            	int startY=threadIndex * height / threads.length;
                            	int endY=(threadIndex + 1) * height / threads.length;
                            	int progress = (int)Math.round(((double)(y-startY)/(endY-startY))*100);
                            	IJ.showStatus("Fitting pixels progress: "+progress+" %  of cycle "+(cycleNum+1)+" of "+numCycles+" total cycles");
							}
                            for (int x = 0; x < width; x++) {
                                for (int z = 0; z < timeData.length; z++) {
                                    timeDataArrayOfArrays[threadIndex][z] = timeData[z];
                                    if(img.isHyperStack()){
	                                    int z2 = img.getStackIndex(img.getC(), img.getZ(), (cycleNum * imagesPerCycle) + z+1)-1;
	                                    pixelsArrayOfArrays[threadIndex][z] = img2.getVoxel(x, y, z2);
                                    }else{
                                     	pixelsArrayOfArrays[threadIndex][z] = img2.getVoxel(x, y, (cycleNum * imagesPerCycle) + z);
                                    }
                               }
                                CurveFitter cf = new CurveFitter(timeDataArrayOfArrays[threadIndex], pixelsArrayOfArrays[threadIndex]);
                                double firstframeint = pixelsArrayOfArrays[threadIndex][0];
                                double lastframeint = pixelsArrayOfArrays[threadIndex][pixelsArrayOfArrays[threadIndex].length - 1];
                                double guess_a = firstframeint - lastframeint;
                                double guess_b = 1/(guess_a*0.37);                                
                                double guess_c = lastframeint;
                                if (guess_a <= 0) {
                                    aZeroDataG[x][y][cycleNum] = 0;
                                    rateDataG[x][y][cycleNum] = 0;
                                    offsetDataG[x][y][cycleNum] = 0;
                                    R2G[x][y][cycleNum] = 0;
                                } else {
                                    double maxiteration = 2000;
                                    double NumRestarts = 2;
                                    double errotTol = 10;
                                    double[] fitparam = {
                                        guess_a,
                                        guess_b,
                                        guess_c,
                                        maxiteration,
                                        NumRestarts,
                                        errotTol
                                    };

                                    cf.setInitialParameters(fitparam);
                                    //cf.getMinimizer().setMaximumThreads(0);
                                    //cf.getMinimizer().setMaxIterations(20);				
                                    //cf.getMinimizer().setMaxRestarts(0);
                                    cf.doFit(11); //exponential decay with offset 
                                    double[] fittedParam = cf.getParams();
                                    double R2 = cf.getRSquared();
                                    //double[] residuals = cf.getResiduals();
                                    if (R2 >= R2CutOff) {
                                        aZeroDataG[x][y][cycleNum] = (float) fittedParam[0];
                                        rateDataG[x][y][cycleNum] = (float) fittedParam[1];
                                        offsetDataG[x][y][cycleNum] = (float) fittedParam[2];
                                        R2G[x][y][cycleNum] = (float) R2;
                                    } else {
                                        aZeroDataG[x][y][cycleNum] = 0;
                                        rateDataG[x][y][cycleNum] = 0;
                                        offsetDataG[x][y][cycleNum] = 0;
                                        R2G[x][y][cycleNum] = 0;
                                    }
                                }
                             }
                        }
                    }
                };
            }
            startAndJoin(threads);
        } //end of cycles  
        rateConstantImage = createRateConstantImage();
     }

    public ImagePlus createRateConstantImage() {
        ImagePlus imp = IJ.createImage("RateConstantsImage", "32-bit", imageW, imageH, numCycles);
        
        for(int cyc=0;cyc<numCycles;cyc++){
            imp.setSlice(cyc+1);
            ImageProcessor ip = imp.getProcessor();
            FloatProcessor fip = (FloatProcessor) ip.convertToFloat();
            for (int y = 0; y < imageH; y++) {
                for (int x = 0; x < imageW; x++) {
                    if (rateDataG[x][y][cyc] == 0) {
                        fip.setf(x, y, Float.NaN);
                    } else {
                        fip.setf(x, y, (float) rateDataG[x][y][cyc]);
                    }
                }
            }
        IJ.resetMinAndMax(imp);
        } 
        imp.show();
        return imp;
    }
    
        public ImagePlus createOffsetImage() {
        ImagePlus imp = IJ.createImage("OffsetImage", "32-bit", imageW, imageH, numCycles);
        
        for(int cyc=0;cyc<numCycles;cyc++){
            imp.setSlice(cyc+1);
            ImageProcessor ip = imp.getProcessor();
            FloatProcessor fip = (FloatProcessor) ip.convertToFloat();
            for (int y = 0; y < imageH; y++) {
                for (int x = 0; x < imageW; x++) {
                    if (offsetDataG[x][y][cyc] == 0) {
                        fip.setf(x, y, Float.NaN);
                    } else {
                        fip.setf(x, y, (float) offsetDataG[x][y][cyc]);
                    }
                }
            }
        IJ.resetMinAndMax(imp);
        } 
        imp.show();
        return imp;
    }
        
    public ImagePlus createAZeroImage() {
        ImagePlus imp = IJ.createImage("AZeroImage", "32-bit", imageW, imageH, numCycles);
        
        for(int cyc=0;cyc<numCycles;cyc++){
            imp.setSlice(cyc+1);
            ImageProcessor ip = imp.getProcessor();
            FloatProcessor fip = (FloatProcessor) ip.convertToFloat();
            for (int y = 0; y < imageH; y++) {
                for (int x = 0; x < imageW; x++) {
                    if (aZeroDataG[x][y][cyc] == 0) {
                        fip.setf(x, y, Float.NaN);
                    } else {
                        fip.setf(x, y, (float) aZeroDataG[x][y][cyc]);
                    }
                }
            }
        IJ.resetMinAndMax(imp);
        } 
        imp.show();
        return imp;
    }
    
        public ImagePlus createR2Image() {
        ImagePlus imp = IJ.createImage("R2Image", "32-bit", imageW, imageH, numCycles);
        
        for(int cyc=0;cyc<numCycles;cyc++){
            imp.setSlice(cyc+1);
            ImageProcessor ip = imp.getProcessor();
            FloatProcessor fip = (FloatProcessor) ip.convertToFloat();
            for (int y = 0; y < imageH; y++) {
                for (int x = 0; x < imageW; x++) {
                    if (R2G[x][y][cyc] == 0) {
                        fip.setf(x, y, Float.NaN);
                    } else {
                        fip.setf(x, y, (float) R2G[x][y][cyc]);
                    }
                }
            }
        IJ.resetMinAndMax(imp);
        } 
        imp.show();
        return imp;
    }

    
public void setUpListeners(){
        String[] imageTitles = WindowManager.getImageTitles();
        listenersRemoved=false;
        ImageWindow win = img.getWindow();
        win.addWindowListener(win);
        canvas = win.getCanvas();
        canvas.addMouseListener(this);
        
        for (String imageTitle : imageTitles) {
            if (imageTitle.contains("RateConstantsImage")) {
                rateConstantImage = WindowManager.getImage(imageTitle);
                ImageWindow win2 = rateConstantImage.getWindow();
                win2.addWindowListener(win2);
                canvas2 = win2.getCanvas();
                canvas2.addMouseListener(this);
            }
        }
        
        xAxis = timeData3;
        xLabel = "Time (sec)";
        yLabel = "Fluorescence";
}

    
   void positionPlotWindow() {
        IJ.wait(500);
        if (pwin==null || img==null) return;
           ImageWindow iwin = img.getWindow();
        if (iwin==null) return;
           Dimension screen = Toolkit.getDefaultToolkit().getScreenSize();
           Dimension plotSize = pwin.getSize();
           Dimension imageSize = iwin.getSize();
        if (plotSize.width==0 || imageSize.width==0) return;
           Point imageLoc = iwin.getLocation();
        int w = imageLoc.x+imageSize.width+10;
        if (w+plotSize.width>screen.width)
           w = screen.width-plotSize.width;
        pwin.setLocation(w, imageLoc.y);
        iwin.toFront();
   }

    @Override
    public void mousePressed(MouseEvent e) {
//Gets the Z values through a single point at (x,y). 
            
             ImageStack stack = img.getStack();
             int size = stack.getSize(); 
             double[] values = new double[size];
                xpoint = e.getX();
                ypoint = e.getY();
                float[] cTable = img.getCalibration().getCTable();
                if(img.isHyperStack()){
                    for (int p=1; p<=img.getNFrames(); p++){
                        int z2 = img.getStackIndex(img.getC(), img.getZ(), p)-1;
                        values[p-1] = stack.getVoxel(xpoint, ypoint, z2);
                    }
                }else{
                    for (int p=1; p<=size; p++){
                       ImageProcessor ip = stack.getProcessor(p);
                       ip.setCalibrationTable(cTable);
                       values[p-1] = ip.getPixelValue(xpoint, ypoint);
                    }
                }
             
             img.setRoi(xpoint,ypoint,1,1);
             rateConstantImage.setRoi(xpoint,ypoint,1,1);
            yAxis = values;
            xAxis = timeData3;
            updateProfile(xAxis, yAxis);

    }
  


    void updateProfile(double[] x, double[] y) {
	if (!isSelection())
            return;
	checkPlotWindow();
	if (listenersRemoved || y==null || y.length==0)
            return;
	Plot plot = new Plot("Data and fit", xLabel, yLabel);
        plot.add("circles", x, y);
        double [] fitToAdd = new double [x.length];
        double [] yForResiduals = new double [x.length];
        if(rateDataG!=null){
            for(int c=0;c<numCycles;c++){
            double [] fitValues = new double [3];
            fitValues[0] = aZeroDataG[xpoint][ypoint][c];
            fitValues[1] = rateDataG[xpoint][ypoint][c];
            fitValues[2] = offsetDataG[xpoint][ypoint][c];
            double [] x2 = new double [imagesPerCycle];
            for(int i=0;i<x2.length;i++){
                x2[i]=x[(c*imagesPerCycle)+i]-x[c*imagesPerCycle];
            }
            double [] fitPerCycle = getTheFit(fitValues, x2);
            for(int i=0;i<fitPerCycle.length;i++){
                fitToAdd[(c*imagesPerCycle)+i] =fitPerCycle[i];
                yForResiduals[(c*imagesPerCycle)+i] =y[(c*imagesPerCycle)+i];
            }
            String labelToAddA = "A="+String.valueOf((double)Math.round(fitValues[0]*1000)/1000);
            String labelToAddK = "k="+String.valueOf((double)Math.round(fitValues[1]*1000)/1000);
            String labelToAddC = "offset="+String.valueOf((double)Math.round(fitValues[2]*1000)/1000);
            String labelToAddR2 = "R2="+String.valueOf((double)Math.round(R2G[xpoint][ypoint][c]*1000)/1000);
            plot.addLabel(c*0.35+0.05,0.1,labelToAddA);
            plot.addLabel(c*0.35+0.05,0.15,labelToAddK);
            plot.addLabel(c*0.35+0.05,0.2,labelToAddC);
            plot.addLabel(c*0.35+0.05,0.25,labelToAddR2);
            }
            plot.add("line", x, fitToAdd);
        }
        
        
	double ymin = ProfilePlot.getFixedMin();
	double ymax= ProfilePlot.getFixedMax();
	if (!(ymin==0.0 && ymax==0.0)) {
		double[] a = Tools.getMinMax(x);
		double xmin=a[0]; double xmax=a[1];
		plot.setLimits(xmin, xmax, ymin, ymax);
	}
        Plot plotResiduals = new Plot("Residuals", xLabel, yLabel);
        if(rateDataG!=null){
        double [] resArray = subtractArrayFromArray(yForResiduals,fitToAdd);
        plotResiduals.add("circles", x, resArray);
        if (!(ymin==0.0 && ymax==0.0)) {
		double[] a = Tools.getMinMax(x);
		double xmin=a[0]; double xmax=a[1];
		plotResiduals.setLimits(xmin, xmax, ymin, ymax);
	}
        }
	if (pwin==null)
            pwin = plot.show();
        else
            pwin.drawPlot(plot);
        if(rateDataG!=null){
	if (pwin2==null)
            pwin2 = plotResiduals.show();
        else
            pwin2.drawPlot(plotResiduals); 
        }
    }

    // returns false if image is closed
    boolean isSelection() {
        return img != null;
    }

    // stop listening for mouse and key events if the plot window has been closed
    void checkPlotWindow() {
       if (pwin==null)
           return;
       if (pwin.isVisible()) 
           return;
       ImageWindow iwin = img.getWindow();
       if (iwin==null)
            return;
       canvas = iwin.getCanvas();
       canvas.removeMouseListener(this);
       ImageWindow iwin2 = rateConstantImage.getWindow();
       canvas2 = iwin2.getCanvas();
       canvas2.removeMouseListener(this);
       pwin = null;
       pwin2 = null;
       listenersRemoved = true;
    }

    public void keyPressed(KeyEvent e) {}
    public void keyTyped(KeyEvent e) {}
    public void mouseReleased(MouseEvent e) {}
    public void mouseExited(MouseEvent e) {}
    public void mouseClicked(MouseEvent e) {}   
    public void mouseEntered(MouseEvent e) {}
    public void mouseMoved(MouseEvent e) {}
    public void mouseDragged(MouseEvent e) {}  
    public void keyReleased(KeyEvent e) {}
    
    

    public double[] getTheFit(double[] fitParameters, double[] timePoints) {
        double[] theFit = new double[timePoints.length];
        for (int tp = 0; tp < timePoints.length; tp++) {
            theFit[tp] = fitParameters[0] * Math.exp(-fitParameters[1] * timePoints[tp]) + fitParameters[2];
        }
        return theFit;
    }



    /** Create a Thread[] array as large as the number of processors available. 
    * From Stephan Preibisch's Multithreading.java class. See: 
    * http://repo.or.cz/w/trakem2.git?a=blob;f=mpi/fruitfly/general/MultiThreading.java;hb=HEAD 
    */  
    private Thread[] newThreadArray() {  
        int n_cpus = Runtime.getRuntime().availableProcessors();  
        return new Thread[n_cpus];
    }  
  
    /** Start all given threads and wait on each of them until all are done. 
    * From Stephan Preibisch's Multithreading.java class. See: 
    * http://repo.or.cz/w/trakem2.git?a=blob;f=mpi/fruitfly/general/MultiThreading.java;hb=HEAD 
     * @param threads
    */  
    public static void startAndJoin(Thread[] threads)  
    {  
        for (int ithread = 0; ithread < threads.length; ++ithread)  
        {  
            threads[ithread].setPriority(Thread.NORM_PRIORITY);  
            threads[ithread].start();  
        }  
  
        try  
        {     
            for (int ithread = 0; ithread < threads.length; ++ithread)  
                threads[ithread].join();  
        } catch (InterruptedException ie)  
        {  
            throw new RuntimeException(ie);  
        } 
    }  
  
    
    public double[] getArrayStatistics (double[] theArray)
    {
    
        double min = theArray[0];
        double max = theArray[0];
        double sum = 0;
        for(int i=0;i<theArray.length;i++){
            if(theArray[i]<min)
                min=theArray[i];
            if(theArray[i]>max)
                max=theArray[i];
            sum = sum + theArray[i];
        }
        double mean = sum/theArray.length;
        double [] returnArray = {min,max,sum,mean};
        return returnArray;
    }

    
    private double[] getTimingPerPlane(String arg, int tPoints, int currZ, int currCh) throws Exception {
    String fExt = arg.substring(arg.indexOf("."), arg.length());
	    if(fExt.contains(" ") && fExt.indexOf(" ")<arg.length())
	    	fExt = fExt.substring(0, fExt.indexOf(" "));
	    String id2 = arg.substring(0, arg.indexOf("."))+fExt;
	    double[] timeStampsToReturn = new double[tPoints];
	    IFormatReader reader = null;
	    int series = 0;
	try{
    	ServiceFactory factory = new ServiceFactory();
     	OMEXMLService service = factory.getInstance(OMEXMLService.class);
    	IMetadata meta = service.createOMEXMLMetadata();
    	// create format reader
    	reader = new ImageReader();
    	reader.setMetadataStore(meta);
     	// initialize file
    	reader.setId(id2);
        
    	int seriesCount = reader.getSeriesCount();
			
	   if (series < seriesCount) 
	    	reader.setSeries(series);
	    series = reader.getSeries();
	    int planeCount = meta.getPlaneCount(series);
		int tCounter=0;
	    for (int i = 0; i < planeCount; i++) {
	      Time deltaT = meta.getPlaneDeltaT(series, i);
	      if (deltaT == null) continue;
	      // convert plane ZCT coordinates into image plane index
	      int z = meta.getPlaneTheZ(series, i).getValue();
	      int c = meta.getPlaneTheC(series, i).getValue();
	      int t = meta.getPlaneTheT(series, i).getValue();
	        if(z==currZ && c==currCh){
	        	timeStampsToReturn[tCounter] = deltaT.value(UNITS.SECOND).doubleValue();
	        	tCounter++;
	        }
	    }
        if(planeCount==0){
        	GenericDialog gd2 = new GenericDialog("Problem with metadata");
        	gd2.addMessage("Time information from metadata was not found");
        	gd2.addMessage("Would you like to enter the time interval manually?");
        	gd2.addNumericField("Time between images in seconds", 0.050, 3);
			gd2.showDialog();
				if(gd2.wasCanceled())
					return null;
        	double userDeltaT = gd2.getNextNumber();
	        for(int t=0; t<timeStampsToReturn.length;t++){
	        	timeStampsToReturn[t] = t*userDeltaT;
	        }
        }	    
		} catch (IOException e) {
            e.printStackTrace();
        }finally {
            try {
                if (reader != null) {
                    reader.close();
                }
            } catch (IOException ex) {
                ex.printStackTrace();
            }
        }
        return timeStampsToReturn;
  }

    
    private ImagePlus applyLookupTables(IFormatReader r, ImagePlus imp,
    byte[][][] lookupTable)
  {
    // apply color lookup tables, if present
    // this requires ImageJ v1.39 or higher
    if (r.isIndexed()) {
      CompositeImage composite =
        new CompositeImage(imp, CompositeImage.COLOR);
      for (int c=0; c<r.getSizeC(); c++) {
        composite.setPosition(c + 1, 1, 1);
        LUT lut =
          new LUT(lookupTable[c][0], lookupTable[c][1], lookupTable[c][2]);
        composite.setChannelLut(lut);
      }
      composite.setPosition(1, 1, 1);
      return composite;
    }
    return imp;
  }
    
    private static double [] subtractArrayFromArray(double [] array1, double [] array2){
	double [] arrayToReturn = new double [array1.length];
	for(int i=0; i<array1.length;i++){
            arrayToReturn[i]=array1[i]-array2[i];
	}
        return arrayToReturn;
    }
    
}



