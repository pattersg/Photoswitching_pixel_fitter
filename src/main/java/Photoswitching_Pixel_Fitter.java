/*
 * /*
Acknowledgements
The code in this plugin was written using shared resources from several places.  
I include links to the sites from which the shared code was accessed.
https://github.com/openmicroscopy/bioformats/blob/develop/components/formats-gpl/utils/PrintTimestamps.java
https://albert.rierol.net/imagej_programming_tutorials.html
https://imagej.nih.gov/ij/plugins/download/Z_Profiler.java

Disclaimer
This plugin was developed at the National Institutes of Health by an employee of the Federal Government
in the course of his official duties. Pursuant to Title 17, Section 105 of the United States Code, this plugin 
is not subject to copyright protection and is in the public domain. NIH assumes no responsibility whatsoever 
for its use by other parties, and makes no guarantees, expressed or implied, about its quality, reliability, 
or any other characteristic.
 * #L%
 */

/**
 *
 * @author pattersg
 */
import ij.*;
import ij.IJ;
import ij.io.*;
import ij.gui.*;
import ij.process.*;
import ij.measure.*;
import java.awt.*;
import java.io.IOException;
import ij.util.Tools;
import java.awt.event.*;
import java.io.File;
import java.util.Arrays;

import loci.formats.FormatException;
import loci.formats.IFormatReader;
import loci.plugins.*;

import java.util.logging.Level;
import java.util.logging.Logger;

import loci.common.services.ServiceFactory;
import loci.formats.ImageReader;
import loci.formats.meta.IMetadata;
import loci.formats.services.OMEXMLService;

import ome.units.quantity.Time;
import ome.units.UNITS;

public class Photoswitching_Pixel_Fitter extends javax.swing.JFrame implements UserFunction, MouseListener, MouseMotionListener, Measurements, KeyListener {

    int imageH;
    int imageW;
    int imageD;
    int imageZ;
    int imageF;
    int numCycles;
    int imagesPerCycle;
    double R2CutOff;
    double Chi2CutOff;
    double[] timeData;
    double[] timeData3;
    double[][][] rateDataG;
    double[][][] offsetDataG;
    double[][][] aZeroDataG;
    double[][][] R2G;
    double[][][] Chi2G;
    double[][][] a2DataG;
    double[][][] k2DataG;
    String id;
    ImagePlus img;
    ImageCanvas canvas;
    ImageCanvas canvas2;
    PlotWindow pwin;
    PlotWindow pwin2;
    public double[] yAxis;
    public double[] xAxis;
    String xLabel;
    String yLabel;
    boolean listenersRemoved;
    int xpoint, ypoint;
    ImagePlus rateConstantImage;
    ImagePlus offsetImage;
    ImagePlus aZeroImage;
    ImagePlus Chi2Image;
    boolean chWarnOff;
    boolean yLog;
    boolean LogFitTime;
    int maxiteration;
    int numRestarts;
    boolean fitSingle;
    boolean fitDouble;
    int cameraOffset;
    int binFactor;
    double cameraGain;
    private static double lambda;
    private static double NA;
    private static double pixSize;
    private static int binFactorImage;
    /**
     * Creates new form NewJFrame
     */
    public Photoswitching_Pixel_Fitter() {
        initComponents();
        setVisible(true);
        //new ij.ImageJ();
        checkFitDouble.setVisible(false);
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jTabbedPane2 = new javax.swing.JTabbedPane();
        Control = new javax.swing.JPanel();
        OpenStack = new javax.swing.JButton();
        makeRateConstantImage = new javax.swing.JButton();
        FitStack = new javax.swing.JButton();
        ExaminePixels = new javax.swing.JButton();
        MakeSaveFitParameterImage = new javax.swing.JButton();
        UseLogScale = new javax.swing.JCheckBox();
        logFitTimes = new javax.swing.JCheckBox();
        Fitting = new javax.swing.JPanel();
        numCyclesLabel = new javax.swing.JLabel();
        numCyclesTF = new javax.swing.JFormattedTextField();
        imagesPerCycleLabel = new javax.swing.JLabel();
        imagesPerCycleTF = new javax.swing.JFormattedTextField();
        imagesPerCycleLabel1 = new javax.swing.JLabel();
        R2CutOffTF = new javax.swing.JFormattedTextField();
        ExperimentalLabel = new javax.swing.JLabel();
        CurveFittingLabel = new javax.swing.JLabel();
        maxIterationsLabel = new javax.swing.JLabel();
        maxIterationsTF = new javax.swing.JFormattedTextField();
        numRestartsLabel = new javax.swing.JLabel();
        numRestartsTF = new javax.swing.JFormattedTextField();
        checkFitSingle = new javax.swing.JCheckBox();
        checkFitDouble = new javax.swing.JCheckBox();
        Chi2CutoffLabel = new javax.swing.JLabel();
        Chi2CutOffTF = new javax.swing.JFormattedTextField();
        Instrument = new javax.swing.JPanel();
        cameraOffsetTF = new javax.swing.JFormattedTextField();
        cameraOffsetLabel = new javax.swing.JLabel();
        binFactorLabel = new javax.swing.JLabel();
        binFactorTF = new javax.swing.JFormattedTextField();
        cameraGainLabel = new javax.swing.JLabel();
        cameraGainTF = new javax.swing.JFormattedTextField();
        ObjectiveNAText = new javax.swing.JLabel();
        ObjectiveNATF = new javax.swing.JTextField();
        emissionLambdaTF = new javax.swing.JTextField();
        emissionLambdaText = new javax.swing.JLabel();
        emissionLambdaText1 = new javax.swing.JLabel();
        pixelSizeTF = new javax.swing.JTextField();
        binFactorImageTF = new javax.swing.JTextField();
        binFactorImageText = new javax.swing.JLabel();
        ImagePixelSizeText = new javax.swing.JLabel();
        imagePixelSizeTF = new javax.swing.JTextField();
        ImagePixelSizeText1 = new javax.swing.JLabel();

        setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);
        setTitle("Photoswitching Pixel Fitter");
        setResizable(false);

        OpenStack.setText("Import with Bio-Formats");
        OpenStack.setMaximumSize(new java.awt.Dimension(200, 30));
        OpenStack.setPreferredSize(new java.awt.Dimension(200, 30));
        OpenStack.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                OpenStackActionPerformed(evt);
            }
        });

        makeRateConstantImage.setText("Remake rate constant image");
        makeRateConstantImage.setToolTipText("");
        makeRateConstantImage.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                makeRateConstantImageActionPerformed(evt);
            }
        });

        FitStack.setText("Fit pixels with exponential");
        FitStack.setMaximumSize(new java.awt.Dimension(200, 30));
        FitStack.setMinimumSize(new java.awt.Dimension(200, 30));
        FitStack.setPreferredSize(new java.awt.Dimension(200, 30));
        FitStack.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                FitStackActionPerformed(evt);
            }
        });

        ExaminePixels.setText("Examine pixel fits");
        ExaminePixels.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                ExaminePixelsActionPerformed(evt);
            }
        });

        MakeSaveFitParameterImage.setText("Save fit parameters");
        MakeSaveFitParameterImage.setMaximumSize(new java.awt.Dimension(200, 30));
        MakeSaveFitParameterImage.setPreferredSize(new java.awt.Dimension(200, 30));
        MakeSaveFitParameterImage.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                MakeSaveFitParameterImageActionPerformed(evt);
            }
        });

        UseLogScale.setText("Set log scale for pixel viewer");
        UseLogScale.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                UseLogScaleActionPerformed(evt);
            }
        });

        logFitTimes.setText("Log the time required for the fits");
        logFitTimes.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                logFitTimesActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout ControlLayout = new javax.swing.GroupLayout(Control);
        Control.setLayout(ControlLayout);
        ControlLayout.setHorizontalGroup(
            ControlLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(ControlLayout.createSequentialGroup()
                .addGroup(ControlLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(ControlLayout.createSequentialGroup()
                        .addGap(18, 18, 18)
                        .addGroup(ControlLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(FitStack, javax.swing.GroupLayout.PREFERRED_SIZE, 236, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(OpenStack, javax.swing.GroupLayout.PREFERRED_SIZE, 236, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(logFitTimes)))
                    .addGroup(ControlLayout.createSequentialGroup()
                        .addGap(15, 15, 15)
                        .addGroup(ControlLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(MakeSaveFitParameterImage, javax.swing.GroupLayout.PREFERRED_SIZE, 236, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addGroup(ControlLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                                .addComponent(makeRateConstantImage, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                .addComponent(ExaminePixels, javax.swing.GroupLayout.DEFAULT_SIZE, 236, Short.MAX_VALUE))
                            .addComponent(UseLogScale))))
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );
        ControlLayout.setVerticalGroup(
            ControlLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(ControlLayout.createSequentialGroup()
                .addGap(14, 14, 14)
                .addComponent(OpenStack, javax.swing.GroupLayout.PREFERRED_SIZE, 35, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(30, 30, 30)
                .addComponent(FitStack, javax.swing.GroupLayout.PREFERRED_SIZE, 39, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(logFitTimes)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 69, Short.MAX_VALUE)
                .addComponent(makeRateConstantImage)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(ExaminePixels, javax.swing.GroupLayout.PREFERRED_SIZE, 47, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(UseLogScale)
                .addGap(38, 38, 38)
                .addComponent(MakeSaveFitParameterImage, javax.swing.GroupLayout.PREFERRED_SIZE, 46, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(25, 25, 25))
        );

        jTabbedPane2.addTab("Control", Control);

        numCyclesLabel.setText("Number of cycles");

        numCyclesTF.setFormatterFactory(new javax.swing.text.DefaultFormatterFactory(new javax.swing.text.NumberFormatter(java.text.NumberFormat.getIntegerInstance())));
        numCyclesTF.setHorizontalAlignment(javax.swing.JTextField.RIGHT);
        numCyclesTF.setText("3");
        numCyclesTF.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                numCyclesTFActionPerformed(evt);
            }
        });
        numCyclesTF.addPropertyChangeListener(new java.beans.PropertyChangeListener() {
            public void propertyChange(java.beans.PropertyChangeEvent evt) {
                numCyclesTFPropertyChange(evt);
            }
        });

        imagesPerCycleLabel.setText("Images per cycle");

        imagesPerCycleTF.setFormatterFactory(new javax.swing.text.DefaultFormatterFactory(new javax.swing.text.NumberFormatter()));
        imagesPerCycleTF.setHorizontalAlignment(javax.swing.JTextField.RIGHT);
        imagesPerCycleTF.setText("300");
        imagesPerCycleTF.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                imagesPerCycleTFActionPerformed(evt);
            }
        });
        imagesPerCycleTF.addPropertyChangeListener(new java.beans.PropertyChangeListener() {
            public void propertyChange(java.beans.PropertyChangeEvent evt) {
                imagesPerCycleTFPropertyChange(evt);
            }
        });

        imagesPerCycleLabel1.setHorizontalAlignment(javax.swing.SwingConstants.RIGHT);
        imagesPerCycleLabel1.setText("R2 cutoff");

        R2CutOffTF.setHorizontalAlignment(javax.swing.JTextField.RIGHT);
        R2CutOffTF.setText("0.9");
        R2CutOffTF.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                R2CutOffTFActionPerformed(evt);
            }
        });
        R2CutOffTF.addPropertyChangeListener(new java.beans.PropertyChangeListener() {
            public void propertyChange(java.beans.PropertyChangeEvent evt) {
                R2CutOffTFPropertyChange(evt);
            }
        });

        ExperimentalLabel.setFont(new java.awt.Font("Lucida Grande", 0, 18)); // NOI18N
        ExperimentalLabel.setText("Experimental");

        CurveFittingLabel.setFont(new java.awt.Font("Lucida Grande", 0, 18)); // NOI18N
        CurveFittingLabel.setText("Curve Fitting");

        maxIterationsLabel.setText("Max iterations");

        maxIterationsTF.setFormatterFactory(new javax.swing.text.DefaultFormatterFactory(new javax.swing.text.NumberFormatter()));
        maxIterationsTF.setHorizontalAlignment(javax.swing.JTextField.RIGHT);
        maxIterationsTF.setText("2000");
        maxIterationsTF.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                maxIterationsTFActionPerformed(evt);
            }
        });
        maxIterationsTF.addPropertyChangeListener(new java.beans.PropertyChangeListener() {
            public void propertyChange(java.beans.PropertyChangeEvent evt) {
                maxIterationsTFPropertyChange(evt);
            }
        });

        numRestartsLabel.setText("Number restarts");

        numRestartsTF.setFormatterFactory(new javax.swing.text.DefaultFormatterFactory(new javax.swing.text.NumberFormatter()));
        numRestartsTF.setHorizontalAlignment(javax.swing.JTextField.RIGHT);
        numRestartsTF.setText("2");
        numRestartsTF.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                numRestartsTFActionPerformed(evt);
            }
        });
        numRestartsTF.addPropertyChangeListener(new java.beans.PropertyChangeListener() {
            public void propertyChange(java.beans.PropertyChangeEvent evt) {
                numRestartsTFPropertyChange(evt);
            }
        });

        checkFitSingle.setSelected(true);
        checkFitSingle.setText("Fit Single Exponential with Offset");
        checkFitSingle.addItemListener(new java.awt.event.ItemListener() {
            public void itemStateChanged(java.awt.event.ItemEvent evt) {
                checkFitSingleItemStateChanged(evt);
            }
        });

        checkFitDouble.setText("Fit Double Exponential with Offset");
        checkFitDouble.addItemListener(new java.awt.event.ItemListener() {
            public void itemStateChanged(java.awt.event.ItemEvent evt) {
                checkFitDoubleItemStateChanged(evt);
            }
        });

        Chi2CutoffLabel.setHorizontalAlignment(javax.swing.SwingConstants.RIGHT);
        Chi2CutoffLabel.setText("Chi2 cutoff");

        Chi2CutOffTF.setHorizontalAlignment(javax.swing.JTextField.RIGHT);
        Chi2CutOffTF.setText("10.0");
        Chi2CutOffTF.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                Chi2CutOffTFActionPerformed(evt);
            }
        });
        Chi2CutOffTF.addPropertyChangeListener(new java.beans.PropertyChangeListener() {
            public void propertyChange(java.beans.PropertyChangeEvent evt) {
                Chi2CutOffTFPropertyChange(evt);
            }
        });

        javax.swing.GroupLayout FittingLayout = new javax.swing.GroupLayout(Fitting);
        Fitting.setLayout(FittingLayout);
        FittingLayout.setHorizontalGroup(
            FittingLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(FittingLayout.createSequentialGroup()
                .addGroup(FittingLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(checkFitSingle)
                    .addComponent(checkFitDouble))
                .addGap(0, 19, Short.MAX_VALUE))
            .addGroup(FittingLayout.createSequentialGroup()
                .addContainerGap()
                .addGroup(FittingLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(FittingLayout.createSequentialGroup()
                        .addGap(0, 0, Short.MAX_VALUE)
                        .addComponent(Chi2CutoffLabel, javax.swing.GroupLayout.PREFERRED_SIZE, 122, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                        .addComponent(Chi2CutOffTF, javax.swing.GroupLayout.PREFERRED_SIZE, 50, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addGap(18, 18, 18))
                    .addGroup(FittingLayout.createSequentialGroup()
                        .addGroup(FittingLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                            .addGroup(FittingLayout.createSequentialGroup()
                                .addGap(54, 54, 54)
                                .addComponent(imagesPerCycleLabel1, javax.swing.GroupLayout.PREFERRED_SIZE, 122, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addGap(18, 18, 18)
                                .addComponent(R2CutOffTF))
                            .addComponent(ExperimentalLabel)
                            .addComponent(CurveFittingLabel)
                            .addGroup(FittingLayout.createSequentialGroup()
                                .addGap(79, 79, 79)
                                .addGroup(FittingLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                                    .addGroup(FittingLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                        .addGroup(FittingLayout.createSequentialGroup()
                                            .addGap(1, 1, 1)
                                            .addComponent(numCyclesLabel)
                                            .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                                            .addComponent(numCyclesTF, javax.swing.GroupLayout.PREFERRED_SIZE, 44, javax.swing.GroupLayout.PREFERRED_SIZE))
                                        .addGroup(FittingLayout.createSequentialGroup()
                                            .addComponent(imagesPerCycleLabel)
                                            .addGap(18, 18, 18)
                                            .addComponent(imagesPerCycleTF, javax.swing.GroupLayout.PREFERRED_SIZE, 44, javax.swing.GroupLayout.PREFERRED_SIZE)))
                                    .addGroup(FittingLayout.createSequentialGroup()
                                        .addGroup(FittingLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                                            .addComponent(maxIterationsLabel)
                                            .addComponent(numRestartsLabel))
                                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                                        .addGroup(FittingLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                                            .addComponent(maxIterationsTF, javax.swing.GroupLayout.DEFAULT_SIZE, 50, Short.MAX_VALUE)
                                            .addComponent(numRestartsTF))))))
                        .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))))
        );
        FittingLayout.setVerticalGroup(
            FittingLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(FittingLayout.createSequentialGroup()
                .addGap(15, 15, 15)
                .addComponent(ExperimentalLabel)
                .addGap(18, 18, 18)
                .addGroup(FittingLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(numCyclesLabel)
                    .addComponent(numCyclesTF, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addGroup(FittingLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(imagesPerCycleLabel)
                    .addComponent(imagesPerCycleTF, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGap(18, 18, 18)
                .addComponent(CurveFittingLabel)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(FittingLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(maxIterationsLabel)
                    .addComponent(maxIterationsTF, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(FittingLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(numRestartsLabel)
                    .addComponent(numRestartsTF, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGap(24, 24, 24)
                .addGroup(FittingLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(imagesPerCycleLabel1, javax.swing.GroupLayout.PREFERRED_SIZE, 26, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(R2CutOffTF, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(FittingLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(Chi2CutoffLabel, javax.swing.GroupLayout.PREFERRED_SIZE, 26, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(Chi2CutOffTF, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 73, Short.MAX_VALUE)
                .addComponent(checkFitSingle)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(checkFitDouble)
                .addContainerGap())
        );

        jTabbedPane2.addTab("Fitting", Fitting);

        cameraOffsetTF.setHorizontalAlignment(javax.swing.JTextField.RIGHT);
        cameraOffsetTF.setText("100");
        cameraOffsetTF.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                cameraOffsetTFActionPerformed(evt);
            }
        });
        cameraOffsetTF.addPropertyChangeListener(new java.beans.PropertyChangeListener() {
            public void propertyChange(java.beans.PropertyChangeEvent evt) {
                cameraOffsetTFPropertyChange(evt);
            }
        });

        cameraOffsetLabel.setHorizontalAlignment(javax.swing.SwingConstants.RIGHT);
        cameraOffsetLabel.setText("Camera Offset");

        binFactorLabel.setHorizontalAlignment(javax.swing.SwingConstants.RIGHT);
        binFactorLabel.setText("Camera Bin Factor");

        binFactorTF.setHorizontalAlignment(javax.swing.JTextField.RIGHT);
        binFactorTF.setText("4");
        binFactorTF.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                binFactorTFActionPerformed(evt);
            }
        });
        binFactorTF.addPropertyChangeListener(new java.beans.PropertyChangeListener() {
            public void propertyChange(java.beans.PropertyChangeEvent evt) {
                binFactorTFPropertyChange(evt);
            }
        });

        cameraGainLabel.setHorizontalAlignment(javax.swing.SwingConstants.RIGHT);
        cameraGainLabel.setText("Camera Gain");

        cameraGainTF.setHorizontalAlignment(javax.swing.JTextField.RIGHT);
        cameraGainTF.setText("2.17");
        cameraGainTF.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                cameraGainTFActionPerformed(evt);
            }
        });
        cameraGainTF.addPropertyChangeListener(new java.beans.PropertyChangeListener() {
            public void propertyChange(java.beans.PropertyChangeEvent evt) {
                cameraGainTFPropertyChange(evt);
            }
        });

        ObjectiveNAText.setHorizontalAlignment(javax.swing.SwingConstants.RIGHT);
        ObjectiveNAText.setText("Objective NA");

        ObjectiveNATF.setHorizontalAlignment(javax.swing.JTextField.TRAILING);
        ObjectiveNATF.setText("1.4");
        ObjectiveNATF.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                ObjectiveNATFActionPerformed(evt);
            }
        });
        ObjectiveNATF.addPropertyChangeListener(new java.beans.PropertyChangeListener() {
            public void propertyChange(java.beans.PropertyChangeEvent evt) {
                ObjectiveNATFPropertyChange(evt);
            }
        });

        emissionLambdaTF.setHorizontalAlignment(javax.swing.JTextField.TRAILING);
        emissionLambdaTF.setText("500");
        emissionLambdaTF.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                emissionLambdaTFActionPerformed(evt);
            }
        });
        emissionLambdaTF.addPropertyChangeListener(new java.beans.PropertyChangeListener() {
            public void propertyChange(java.beans.PropertyChangeEvent evt) {
                emissionLambdaTFPropertyChange(evt);
            }
        });

        emissionLambdaText.setHorizontalAlignment(javax.swing.SwingConstants.RIGHT);
        emissionLambdaText.setText("Emission wavelength (nm)");

        emissionLambdaText1.setHorizontalAlignment(javax.swing.SwingConstants.RIGHT);
        emissionLambdaText1.setText("Unbinned pixel size (nm)");

        pixelSizeTF.setHorizontalAlignment(javax.swing.JTextField.TRAILING);
        pixelSizeTF.setText("39");
        pixelSizeTF.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                pixelSizeTFActionPerformed(evt);
            }
        });
        pixelSizeTF.addPropertyChangeListener(new java.beans.PropertyChangeListener() {
            public void propertyChange(java.beans.PropertyChangeEvent evt) {
                pixelSizeTFPropertyChange(evt);
            }
        });

        binFactorImageTF.setHorizontalAlignment(javax.swing.JTextField.TRAILING);
        binFactorImageTF.setText("1");
        binFactorImageTF.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                binFactorImageTFActionPerformed(evt);
            }
        });
        binFactorImageTF.addPropertyChangeListener(new java.beans.PropertyChangeListener() {
            public void propertyChange(java.beans.PropertyChangeEvent evt) {
                binFactorImageTFPropertyChange(evt);
            }
        });

        binFactorImageText.setHorizontalAlignment(javax.swing.SwingConstants.RIGHT);
        binFactorImageText.setText("Image Bin Factor (Post)");

        ImagePixelSizeText.setHorizontalAlignment(javax.swing.SwingConstants.RIGHT);
        ImagePixelSizeText.setText("Final Image Pixel size =");

        imagePixelSizeTF.setEditable(false);
        imagePixelSizeTF.setHorizontalAlignment(javax.swing.JTextField.TRAILING);
        imagePixelSizeTF.setText("156");
        imagePixelSizeTF.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                imagePixelSizeTFActionPerformed(evt);
            }
        });
        imagePixelSizeTF.addPropertyChangeListener(new java.beans.PropertyChangeListener() {
            public void propertyChange(java.beans.PropertyChangeEvent evt) {
                imagePixelSizeTFPropertyChange(evt);
            }
        });

        ImagePixelSizeText1.setHorizontalAlignment(javax.swing.SwingConstants.RIGHT);
        ImagePixelSizeText1.setText("nm");

        javax.swing.GroupLayout InstrumentLayout = new javax.swing.GroupLayout(Instrument);
        Instrument.setLayout(InstrumentLayout);
        InstrumentLayout.setHorizontalGroup(
            InstrumentLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, InstrumentLayout.createSequentialGroup()
                .addContainerGap()
                .addGroup(InstrumentLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(InstrumentLayout.createSequentialGroup()
                        .addGroup(InstrumentLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                            .addGroup(InstrumentLayout.createSequentialGroup()
                                .addGap(4, 4, 4)
                                .addGroup(InstrumentLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                                    .addComponent(binFactorImageText, javax.swing.GroupLayout.PREFERRED_SIZE, 158, javax.swing.GroupLayout.PREFERRED_SIZE)
                                    .addComponent(binFactorLabel, javax.swing.GroupLayout.PREFERRED_SIZE, 138, javax.swing.GroupLayout.PREFERRED_SIZE)
                                    .addComponent(cameraOffsetLabel, javax.swing.GroupLayout.PREFERRED_SIZE, 150, javax.swing.GroupLayout.PREFERRED_SIZE)
                                    .addComponent(cameraGainLabel, javax.swing.GroupLayout.PREFERRED_SIZE, 140, javax.swing.GroupLayout.PREFERRED_SIZE))
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                                .addGroup(InstrumentLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                    .addComponent(binFactorImageTF)
                                    .addComponent(binFactorTF)
                                    .addComponent(cameraOffsetTF, javax.swing.GroupLayout.Alignment.TRAILING)
                                    .addComponent(cameraGainTF, javax.swing.GroupLayout.Alignment.TRAILING)))
                            .addGroup(InstrumentLayout.createSequentialGroup()
                                .addComponent(ImagePixelSizeText, javax.swing.GroupLayout.DEFAULT_SIZE, 152, Short.MAX_VALUE)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                                .addComponent(imagePixelSizeTF, javax.swing.GroupLayout.PREFERRED_SIZE, 49, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(ImagePixelSizeText1)
                                .addGap(6, 6, 6)))
                        .addGap(17, 17, 17))
                    .addGroup(InstrumentLayout.createSequentialGroup()
                        .addGroup(InstrumentLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                            .addComponent(ObjectiveNAText, javax.swing.GroupLayout.Alignment.TRAILING)
                            .addComponent(emissionLambdaText, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addComponent(emissionLambdaText1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(InstrumentLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(ObjectiveNATF, javax.swing.GroupLayout.PREFERRED_SIZE, 69, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(emissionLambdaTF, javax.swing.GroupLayout.PREFERRED_SIZE, 69, javax.swing.GroupLayout.PREFERRED_SIZE)
                            .addComponent(pixelSizeTF, javax.swing.GroupLayout.PREFERRED_SIZE, 69, javax.swing.GroupLayout.PREFERRED_SIZE)))))
        );
        InstrumentLayout.setVerticalGroup(
            InstrumentLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(InstrumentLayout.createSequentialGroup()
                .addGap(51, 51, 51)
                .addGroup(InstrumentLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(ObjectiveNATF, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(ObjectiveNAText))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(InstrumentLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(emissionLambdaTF, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(emissionLambdaText))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addGroup(InstrumentLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(pixelSizeTF, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(emissionLambdaText1))
                .addGap(30, 30, 30)
                .addGroup(InstrumentLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(binFactorImageTF, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(binFactorImageText))
                .addGap(50, 50, 50)
                .addGroup(InstrumentLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(binFactorTF, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(binFactorLabel, javax.swing.GroupLayout.PREFERRED_SIZE, 26, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGap(5, 5, 5)
                .addGroup(InstrumentLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(cameraOffsetTF, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(cameraOffsetLabel, javax.swing.GroupLayout.PREFERRED_SIZE, 26, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addGroup(InstrumentLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(cameraGainTF, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(cameraGainLabel, javax.swing.GroupLayout.PREFERRED_SIZE, 26, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGap(47, 47, 47)
                .addGroup(InstrumentLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(ImagePixelSizeText)
                    .addComponent(imagePixelSizeTF, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(ImagePixelSizeText1))
                .addGap(27, 27, 27))
        );

        jTabbedPane2.addTab("Instrument", Instrument);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addComponent(jTabbedPane2, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(0, 0, Short.MAX_VALUE))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jTabbedPane2, javax.swing.GroupLayout.PREFERRED_SIZE, 482, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents


    private void FitStackActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_FitStackActionPerformed
        boolean imageOpenAlready = false;
        String[] imageTitles = WindowManager.getImageTitles();
        for (String imageTitle : imageTitles) {
            if (imageTitle.contains("RateConstantsImage")) {
                imageOpenAlready = true;
            }
        }
        if (imageOpenAlready) {
            IJ.showMessage("Pixel Fitter", "Please close the existing rate constants image\nSorry, I'm getting confused");
            return;
        }
        img = IJ.getImage();
        ImageWindow iwin = img.getWindow();
        iwin.addWindowListener(new WindowAdapter()
        {
            @Override
            public void windowClosed(WindowEvent e)
            {
                aZeroDataG = null;
                rateDataG = null;
                offsetDataG = null; 
                Chi2G = null;
            }
        });
        if (img.isHyperStack() && chWarnOff == false) {
            GenericDialog wfc = new GenericDialog("Channel confirmations");
            wfc.addMessage("Have you selected the channel\nyou wish to fit?");
            wfc.addCheckbox("Do not show this warning", false);
            wfc.showDialog();
            if (wfc.wasCanceled()) {
                return;
            }
            chWarnOff = wfc.getNextBoolean();
        }
        try {
            psFRET_Fit_exponential();
        } catch (Exception ex) {
            Logger.getLogger(Photoswitching_Pixel_Fitter.class.getName()).log(Level.SEVERE, null, ex);
        }
    }//GEN-LAST:event_FitStackActionPerformed

    private void OpenStackActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_OpenStackActionPerformed

        OpenDialog stackIsWhere = new OpenDialog("Choose a stack to open", null);
        String dir = stackIsWhere.getDirectory();
        String stackToOpen = stackIsWhere.getFileName();
        id = dir + stackToOpen;
        try {
            //IJ.run("Bio-Formats", "open="+dir+stackToOpen+" autoscale color_mode=Default rois_import=[ROI manager] view=Hyperstack stack_order=XYCZT");
            ImagePlus[] imp = BF.openImagePlus(id);
            imp[0].show();
            img = IJ.getImage();
            ImageWindow iwin = img.getWindow();
            iwin.addWindowListener(new WindowAdapter()
            {
                @Override
                public void windowClosed(WindowEvent e)
                {
                    aZeroDataG = null;
                    rateDataG = null;
                    offsetDataG = null; 
                    Chi2G = null;
                }
            });        
        } catch (FormatException exc) {
            IJ.error("Sorry, an error occurred: " + exc.getMessage());
        } catch (IOException ex) {
            Logger.getLogger(Photoswitching_Pixel_Fitter.class.getName()).log(Level.SEVERE, null, ex);
        }
    }//GEN-LAST:event_OpenStackActionPerformed

    private void ExaminePixelsActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_ExaminePixelsActionPerformed
        if (aZeroDataG == null || rateDataG == null || offsetDataG == null || Chi2G == null) {
            img = IJ.getImage();
            if (img.getTitle().contains("RateConstantsImage") || img.getTitle().contains("AZeroImage") || img.getTitle().contains("OffsetImage") || img.getTitle().contains("Chi2Image")) {
                IJ.showMessage("Pixel Fitter", "Data image selected\nPlease select the raw image data set");
                return;
            }
            boolean imageOpenAlready = false;
            String[] imageTitles = WindowManager.getImageTitles();
            for (String imageTitle : imageTitles) {
                if (imageTitle.contains("RateConstantsImage")) {
                    imageOpenAlready = true;
                }
            }
            if (!imageOpenAlready && rateDataG != null) {
                rateConstantImage = createRateConstantImage();
            }
            //in case the image is opened without using the plugin BioFormats button
            String dir0 = IJ.getDirectory("image");
            String stackToOpen = img.getTitle();
            String id2 = dir0 + stackToOpen;
            String fExt = id2.substring(id2.indexOf("."), id2.length());
            if (fExt.contains(" ") && fExt.indexOf(" ") < id2.length()) {
                fExt = fExt.substring(0, fExt.indexOf(" "));
            }
            id = id2.substring(0, id2.indexOf(".")) + fExt;

            ImageStack img2 = img.getStack();
            imageH = img2.getHeight();
            imageW = img2.getWidth();
            imageD = img2.getBitDepth();
            imageZ = img2.getSize();
            final int currentchannel = img.getC() - 1;
            final int currentZ = img.getZ() - 1;
            final int nSlices = img.getNSlices();
            int size = img.getNFrames();
            if (size == 1)//in case the stack is read as a Z stack instead of T stack
            {
                size = nSlices;
            }
            if (numCycles * imagesPerCycle > size) {
                IJ.showMessage("Pixel Fitter", "The number of cycles multiplied by the number images per cycle is larger than the stack");
                return;
            }
            String id3 = id.substring(0, id.indexOf("."));
            File f1 = new File(id3 + "_RateConstantsImage.tif");
            File f2 = new File(id3 + "_AZeroImage.tif");
            File f3 = new File(id3 + "_OffsetImage.tif");
            File f4 = new File(id3 + "_Chi2Image.tif");
            if (!f1.exists() || !f2.exists() || !f3.exists() || !f4.exists()) {
                IJ.showMessage("Pixel Fitter", "The analyzed data sets were not found in the directory with your image\n" + dir0 + "\nHave you fit this dataset already?");
                return;
            }
            try {
                timeData3 = getTimingPerPlane(id, size, currentZ, currentchannel);
            } catch (Exception e) {
                e.printStackTrace();
            }
            offsetImage = new Opener().openImage(id3 + "_OffsetImage.tif");
            offsetDataG = new double[imageW][imageH][numCycles];
            ImageStack stack = offsetImage.getStack();
            if (stack.getSize() != numCycles) {
                IJ.showMessage("Pixel Fitter", "The size of offsetImage dataset does not match the number of cycles");
                return;
            }
            for (int cyc = 0; cyc < numCycles; cyc++) {
                ImageProcessor ip = stack.getProcessor(cyc + 1);
                for (int x = 0; x < imageW; x++) {
                    for (int y = 0; y < imageH; y++) {
                        offsetDataG[x][y][cyc] = ip.getPixelValue(x, y);
                    }
                }
            }

            aZeroImage = new Opener().openImage(id3 + "_AZeroImage.tif");
            aZeroDataG = new double[imageW][imageH][numCycles];
            stack = aZeroImage.getStack();
            if (stack.getSize() != numCycles) {
                IJ.showMessage("Pixel Fitter", "The size of aZeroImage dataset does not match the number of cycles");
                return;
            }
            for (int cyc = 0; cyc < numCycles; cyc++) {
                ImageProcessor ip = stack.getProcessor(cyc + 1);
                for (int x = 0; x < imageW; x++) {
                    for (int y = 0; y < imageH; y++) {
                        aZeroDataG[x][y][cyc] = ip.getPixelValue(x, y);
                    }
                }
            }

            Chi2Image = new Opener().openImage(id3 + "_Chi2Image.tif");
            Chi2G = new double[imageW][imageH][numCycles];
            stack = Chi2Image.getStack();
            if (stack.getSize() != numCycles) {
                IJ.showMessage("Pixel Fitter", "The size of Chi2Image dataset does not match the number of cycles");
                return;
            }
            for (int cyc = 0; cyc < numCycles; cyc++) {
                ImageProcessor ip = stack.getProcessor(cyc + 1);
                for (int x = 0; x < imageW; x++) {
                    for (int y = 0; y < imageH; y++) {
                        Chi2G[x][y][cyc] = ip.getPixelValue(x, y);
                    }
                }
            }

            rateConstantImage = new Opener().openImage(id3 + "_RateConstantsImage.tif");
            rateDataG = new double[imageW][imageH][numCycles];
            stack = rateConstantImage.getStack();
            if (stack.getSize() != numCycles) {
                IJ.showMessage("Pixel Fitter", "The size of rateConstantImage dataset does not match the number of cycles");
                return;
            }
            for (int cyc = 0; cyc < numCycles; cyc++) {
                ImageProcessor ip = stack.getProcessor(cyc + 1);
                for (int x = 0; x < imageW; x++) {
                    for (int y = 0; y < imageH; y++) {
                        rateDataG[x][y][cyc] = ip.getPixelValue(x, y);
                    }
                }
            }
            rateConstantImage.show();

            setUpListeners();
        } else {
            boolean imageOpenAlready = false;
            String[] imageTitles = WindowManager.getImageTitles();
            for (String imageTitle : imageTitles) {
                if (imageTitle.contains("RateConstantsImage")) {
                    imageOpenAlready = true;
                }
            }
            if (!imageOpenAlready && rateDataG != null) {
                rateConstantImage = createRateConstantImage();
            }
            setUpListeners();
        }

    }//GEN-LAST:event_ExaminePixelsActionPerformed


    private void MakeSaveFitParameterImageActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_MakeSaveFitParameterImageActionPerformed
        if (aZeroDataG == null || rateDataG == null || offsetDataG == null || Chi2G == null) {
            IJ.showMessage("Pixel Fitter", "Fit parameter data unavailable");
        } else {
            String id2 = id.substring(0, id.indexOf("."));
            File f1 = new File(id2 + "_RateConstantsImage.tif");
            File f2 = new File(id2 + "_AZeroImage.tif");
            File f3 = new File(id2 + "_OffsetImage.tif");
            File f4 = new File(id2 + "_Chi2Image.tif.tif");
            if (f1.exists() || f2.exists() || f3.exists() || f4.exists()) {
                GenericDialog gdEx = new GenericDialog("Pixel Fitter");
                gdEx.addMessage("Analyzed results files present for this image\n " + id2);
                gdEx.addCheckbox("Overwrite?", false);
                gdEx.showDialog();
                if (gdEx.wasCanceled()) {
                    return;
                }
                boolean overWrite = gdEx.getNextBoolean();
                if (overWrite) {
                    ImagePlus imp = createRateConstantImage();
                    IJ.saveAs(imp, "Tiff", id2 + "_RateConstantsImage.tif");
                    imp.close();
                    imp = createAZeroImage();
                    IJ.saveAs(imp, "Tiff", id2 + "_AZeroImage.tif");
                    imp.close();
                    imp = createOffsetImage();
                    IJ.saveAs(imp, "Tiff", id2 + "_OffsetImage.tif");
                    imp.close();
                    imp = createChi2Image();
                    IJ.saveAs(imp, "Tiff", id2 + "_Chi2Image.tif");
                    imp.close();
                }
            } else {
                ImagePlus imp = createRateConstantImage();
                IJ.saveAs(imp, "Tiff", id2 + "_RateConstantsImage.tif");
                imp.close();
                imp = createAZeroImage();
                IJ.saveAs(imp, "Tiff", id2 + "_AZeroImage.tif");
                imp.close();
                imp = createOffsetImage();
                IJ.saveAs(imp, "Tiff", id2 + "_OffsetImage.tif");
                imp.close();
                imp = createChi2Image();
                IJ.saveAs(imp, "Tiff", id2 + "_Chi2Image.tif");
                imp.close();
            }
        }
    }//GEN-LAST:event_MakeSaveFitParameterImageActionPerformed

    private void imagesPerCycleTFActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_imagesPerCycleTFActionPerformed
        try {
            imagesPerCycle = Integer.parseInt(imagesPerCycleTF.getText());
        } catch (NumberFormatException e) {
            e.printStackTrace();
        }
    }//GEN-LAST:event_imagesPerCycleTFActionPerformed

    private void numCyclesTFActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_numCyclesTFActionPerformed
        try {
            numCycles = Integer.parseInt(numCyclesTF.getText());
        } catch (NumberFormatException e) {
            e.printStackTrace();
        }
    }//GEN-LAST:event_numCyclesTFActionPerformed

    private void imagesPerCycleTFPropertyChange(java.beans.PropertyChangeEvent evt) {//GEN-FIRST:event_imagesPerCycleTFPropertyChange
        try {
            imagesPerCycle = Integer.parseInt(imagesPerCycleTF.getText());
        } catch (NumberFormatException e) {
            e.printStackTrace();
        }
    }//GEN-LAST:event_imagesPerCycleTFPropertyChange

    private void numCyclesTFPropertyChange(java.beans.PropertyChangeEvent evt) {//GEN-FIRST:event_numCyclesTFPropertyChange
        try {
            numCycles = Integer.parseInt(numCyclesTF.getText());
        } catch (NumberFormatException e) {
            e.printStackTrace();
        }
    }//GEN-LAST:event_numCyclesTFPropertyChange

    private void R2CutOffTFActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_R2CutOffTFActionPerformed
        try {
            R2CutOff = Double.parseDouble(R2CutOffTF.getText());
        } catch (NumberFormatException e) {
            e.printStackTrace();
        }
    }//GEN-LAST:event_R2CutOffTFActionPerformed

    private void R2CutOffTFPropertyChange(java.beans.PropertyChangeEvent evt) {//GEN-FIRST:event_R2CutOffTFPropertyChange
        try {
            R2CutOff = Double.parseDouble(R2CutOffTF.getText());
        } catch (NumberFormatException e) {
            e.printStackTrace();
        }
    }//GEN-LAST:event_R2CutOffTFPropertyChange

    private void makeRateConstantImageActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_makeRateConstantImageActionPerformed
        if (rateDataG == null) {
            IJ.showMessage("Pixel Fitter", "No rate constant data available");
        } else {
            boolean imageOpenAlready = false;
            String[] imageTitles = WindowManager.getImageTitles();
            for (String imageTitle : imageTitles) {
                if (imageTitle.contains("RateConstantsImage")) {
                    imageOpenAlready = true;
                }
            }
            if (!imageOpenAlready) {
                rateConstantImage = createRateConstantImage();
            }
        }
    }//GEN-LAST:event_makeRateConstantImageActionPerformed

    private void UseLogScaleActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_UseLogScaleActionPerformed
        if (UseLogScale.isSelected()) {
            yLog = true;
        }
        if (!UseLogScale.isSelected()) {
            yLog = false;
        }
    }//GEN-LAST:event_UseLogScaleActionPerformed

    private void logFitTimesActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_logFitTimesActionPerformed
        if (logFitTimes.isSelected()) {
            LogFitTime = true;
        }
        if (!logFitTimes.isSelected()) {
            LogFitTime = false;
        }
    }//GEN-LAST:event_logFitTimesActionPerformed

    private void maxIterationsTFActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_maxIterationsTFActionPerformed
        try {
            maxiteration = Integer.parseInt(maxIterationsTF.getText());
        } catch (NumberFormatException e) {
            e.printStackTrace();
        }
    }//GEN-LAST:event_maxIterationsTFActionPerformed

    private void maxIterationsTFPropertyChange(java.beans.PropertyChangeEvent evt) {//GEN-FIRST:event_maxIterationsTFPropertyChange
        try {
            maxiteration = Integer.parseInt(maxIterationsTF.getText());
        } catch (NumberFormatException e) {
            e.printStackTrace();
        }
    }//GEN-LAST:event_maxIterationsTFPropertyChange

    private void numRestartsTFActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_numRestartsTFActionPerformed
        try {
            numRestarts = Integer.parseInt(numRestartsTF.getText());
        } catch (NumberFormatException e) {
            e.printStackTrace();
        }
    }//GEN-LAST:event_numRestartsTFActionPerformed

    private void numRestartsTFPropertyChange(java.beans.PropertyChangeEvent evt) {//GEN-FIRST:event_numRestartsTFPropertyChange
        try {
            numRestarts = Integer.parseInt(numRestartsTF.getText());
        } catch (NumberFormatException e) {
            e.printStackTrace();
        }
    }//GEN-LAST:event_numRestartsTFPropertyChange

    private void checkFitSingleItemStateChanged(java.awt.event.ItemEvent evt) {//GEN-FIRST:event_checkFitSingleItemStateChanged
        if (evt.getStateChange() == ItemEvent.SELECTED) {
            fitSingle = true;
            fitDouble = false;
            checkFitDouble.setSelected(false);
        } 
    }//GEN-LAST:event_checkFitSingleItemStateChanged

    private void checkFitDoubleItemStateChanged(java.awt.event.ItemEvent evt) {//GEN-FIRST:event_checkFitDoubleItemStateChanged
        if (evt.getStateChange() == ItemEvent.SELECTED) {
            /*fitSingle = false;
            fitDouble = true;
            checkFitSingle.setSelected(false);*/
            IJ.showMessage("Sorry, not implemented yet");
            checkFitDouble.setSelected(false);
        } 
    }//GEN-LAST:event_checkFitDoubleItemStateChanged

    private void cameraOffsetTFActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_cameraOffsetTFActionPerformed
        try {
            cameraOffset = Integer.parseInt(cameraOffsetTF.getText()) * (binFactor*binFactor);
        } catch (NumberFormatException e) {
            e.printStackTrace();
        }
    }//GEN-LAST:event_cameraOffsetTFActionPerformed

    private void cameraOffsetTFPropertyChange(java.beans.PropertyChangeEvent evt) {//GEN-FIRST:event_cameraOffsetTFPropertyChange
        try {
            cameraOffset = Integer.parseInt(cameraOffsetTF.getText()) * (binFactor*binFactor);
        } catch (NumberFormatException e) {
            e.printStackTrace();
        }
    }//GEN-LAST:event_cameraOffsetTFPropertyChange

    private void binFactorTFActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_binFactorTFActionPerformed
        try {
            binFactor = Integer.parseInt(binFactorTF.getText());
        } catch (NumberFormatException e) {
            e.printStackTrace();
        }
    }//GEN-LAST:event_binFactorTFActionPerformed

    private void binFactorTFPropertyChange(java.beans.PropertyChangeEvent evt) {//GEN-FIRST:event_binFactorTFPropertyChange
        try {
            binFactor = Integer.parseInt(binFactorTF.getText());
        } catch (NumberFormatException e) {
            e.printStackTrace();
        }
    }//GEN-LAST:event_binFactorTFPropertyChange

    private void cameraGainTFActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_cameraGainTFActionPerformed
        try {
            cameraGain = Double.parseDouble(cameraGainTF.getText());
        } catch (NumberFormatException e) {
            e.printStackTrace();
        }
    }//GEN-LAST:event_cameraGainTFActionPerformed

    private void cameraGainTFPropertyChange(java.beans.PropertyChangeEvent evt) {//GEN-FIRST:event_cameraGainTFPropertyChange
        try {
            cameraGain = Double.parseDouble(cameraGainTF.getText());
        } catch (NumberFormatException e) {
            e.printStackTrace();
        }
    }//GEN-LAST:event_cameraGainTFPropertyChange

    private void ObjectiveNATFActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_ObjectiveNATFActionPerformed
        NA = Double.parseDouble(ObjectiveNATF.getText());
    }//GEN-LAST:event_ObjectiveNATFActionPerformed

    private void ObjectiveNATFPropertyChange(java.beans.PropertyChangeEvent evt) {//GEN-FIRST:event_ObjectiveNATFPropertyChange
        NA = Double.parseDouble(ObjectiveNATF.getText());
    }//GEN-LAST:event_ObjectiveNATFPropertyChange

    private void emissionLambdaTFActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_emissionLambdaTFActionPerformed
        lambda = Double.parseDouble(emissionLambdaTF.getText());
    }//GEN-LAST:event_emissionLambdaTFActionPerformed

    private void emissionLambdaTFPropertyChange(java.beans.PropertyChangeEvent evt) {//GEN-FIRST:event_emissionLambdaTFPropertyChange
        lambda = Double.parseDouble(emissionLambdaTF.getText());
    }//GEN-LAST:event_emissionLambdaTFPropertyChange

    private void pixelSizeTFActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_pixelSizeTFActionPerformed
        pixSize = Double.parseDouble(pixelSizeTF.getText());
        imagePixelSizeTF.setText(String.valueOf((int)pixSize*binFactor*binFactorImage));
    }//GEN-LAST:event_pixelSizeTFActionPerformed

    private void pixelSizeTFPropertyChange(java.beans.PropertyChangeEvent evt) {//GEN-FIRST:event_pixelSizeTFPropertyChange
        pixSize = Double.parseDouble(pixelSizeTF.getText());
        imagePixelSizeTF.setText(String.valueOf((int)pixSize*binFactor*binFactorImage));
    }//GEN-LAST:event_pixelSizeTFPropertyChange

    private void binFactorImageTFActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_binFactorImageTFActionPerformed
        binFactorImage = Integer.parseInt(binFactorImageTF.getText());
        imagePixelSizeTF.setText(String.valueOf((int)pixSize*binFactor*binFactorImage));
    }//GEN-LAST:event_binFactorImageTFActionPerformed

    private void binFactorImageTFPropertyChange(java.beans.PropertyChangeEvent evt) {//GEN-FIRST:event_binFactorImageTFPropertyChange
        binFactorImage = Integer.parseInt(binFactorImageTF.getText());
        imagePixelSizeTF.setText(String.valueOf((int)pixSize*binFactor*binFactorImage));
    }//GEN-LAST:event_binFactorImageTFPropertyChange

    private void Chi2CutOffTFActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_Chi2CutOffTFActionPerformed
        Chi2CutOff = Double.parseDouble(Chi2CutOffTF.getText());
    }//GEN-LAST:event_Chi2CutOffTFActionPerformed

    private void Chi2CutOffTFPropertyChange(java.beans.PropertyChangeEvent evt) {//GEN-FIRST:event_Chi2CutOffTFPropertyChange
        Chi2CutOff = Double.parseDouble(Chi2CutOffTF.getText());
    }//GEN-LAST:event_Chi2CutOffTFPropertyChange

    private void imagePixelSizeTFActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_imagePixelSizeTFActionPerformed
        imagePixelSizeTF.setText(String.valueOf((int)pixSize*binFactor*binFactorImage));
    }//GEN-LAST:event_imagePixelSizeTFActionPerformed

    private void imagePixelSizeTFPropertyChange(java.beans.PropertyChangeEvent evt) {//GEN-FIRST:event_imagePixelSizeTFPropertyChange
        imagePixelSizeTF.setText(String.valueOf((int)pixSize*binFactor*binFactorImage));
    }//GEN-LAST:event_imagePixelSizeTFPropertyChange

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        //new ij.ImageJ();
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(Photoswitching_Pixel_Fitter.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(Photoswitching_Pixel_Fitter.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(Photoswitching_Pixel_Fitter.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(Photoswitching_Pixel_Fitter.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            @Override
            public void run() {
                new Photoswitching_Pixel_Fitter().setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JFormattedTextField Chi2CutOffTF;
    private javax.swing.JLabel Chi2CutoffLabel;
    private javax.swing.JPanel Control;
    private javax.swing.JLabel CurveFittingLabel;
    private javax.swing.JButton ExaminePixels;
    private javax.swing.JLabel ExperimentalLabel;
    private javax.swing.JButton FitStack;
    private javax.swing.JPanel Fitting;
    private javax.swing.JLabel ImagePixelSizeText;
    private javax.swing.JLabel ImagePixelSizeText1;
    private javax.swing.JPanel Instrument;
    private javax.swing.JButton MakeSaveFitParameterImage;
    private javax.swing.JTextField ObjectiveNATF;
    private javax.swing.JLabel ObjectiveNAText;
    private javax.swing.JButton OpenStack;
    private javax.swing.JFormattedTextField R2CutOffTF;
    private javax.swing.JCheckBox UseLogScale;
    private javax.swing.JTextField binFactorImageTF;
    private javax.swing.JLabel binFactorImageText;
    private javax.swing.JLabel binFactorLabel;
    private javax.swing.JFormattedTextField binFactorTF;
    private javax.swing.JLabel cameraGainLabel;
    private javax.swing.JFormattedTextField cameraGainTF;
    private javax.swing.JLabel cameraOffsetLabel;
    private javax.swing.JFormattedTextField cameraOffsetTF;
    private javax.swing.JCheckBox checkFitDouble;
    private javax.swing.JCheckBox checkFitSingle;
    private javax.swing.JTextField emissionLambdaTF;
    private javax.swing.JLabel emissionLambdaText;
    private javax.swing.JLabel emissionLambdaText1;
    private javax.swing.JTextField imagePixelSizeTF;
    private javax.swing.JLabel imagesPerCycleLabel;
    private javax.swing.JLabel imagesPerCycleLabel1;
    private javax.swing.JFormattedTextField imagesPerCycleTF;
    private javax.swing.JTabbedPane jTabbedPane2;
    private javax.swing.JCheckBox logFitTimes;
    private javax.swing.JButton makeRateConstantImage;
    private javax.swing.JLabel maxIterationsLabel;
    private javax.swing.JFormattedTextField maxIterationsTF;
    private javax.swing.JLabel numCyclesLabel;
    private javax.swing.JFormattedTextField numCyclesTF;
    private javax.swing.JLabel numRestartsLabel;
    private javax.swing.JFormattedTextField numRestartsTF;
    private javax.swing.JTextField pixelSizeTF;
    // End of variables declaration//GEN-END:variables

    public void psFRET_Fit_exponential() throws Exception {
        IJ.resetMinAndMax(img);
        //in case the image is opened without using the plugin BioFormats button
        String dir0 = IJ.getDirectory("image");
        String stackToOpen = img.getTitle();
        String id2 = dir0 + stackToOpen;
        String fExt = id2.substring(id2.indexOf("."), id2.length());
        if (fExt.contains(" ") && fExt.indexOf(" ") < id2.length()) {
            fExt = fExt.substring(0, fExt.indexOf(" "));
        }
        id = id2.substring(0, id2.indexOf(".")) + fExt;

        final ImageStack img2 = img.getStack();
        imageH = img2.getHeight();
        imageW = img2.getWidth();
        imageD = img2.getBitDepth();
        imageZ = img2.getSize();
        final int currentchannel = img.getC() - 1;
        final int currentZ = img.getZ() - 1;
        final int nSlices = img.getNSlices();
        int size = img.getNFrames();
        if (size == 1)//in case the stack is read as a Z stack instead of T stack
        {
            size = nSlices;
        }
        if (numCycles * imagesPerCycle > size) {
            IJ.showMessage("Pixel Fitter", "The number of cycles multiplied by the number images per cycle is larger than the stack");
            return;
        }
        try {
            timeData3 = getTimingPerPlane(id, size, currentZ, currentchannel);
        } catch (Exception e) {
            e.printStackTrace();
        }
        rateDataG = new double[imageW][imageH][numCycles];
        offsetDataG = new double[imageW][imageH][numCycles];
        aZeroDataG = new double[imageW][imageH][numCycles];
        R2G = new double[imageW][imageH][numCycles];
        Chi2G = new double[imageW][imageH][numCycles];

        for (int cycle = 0; cycle < numCycles; cycle++) {
            final long startTime = System.currentTimeMillis();
            double[] timeData2 = new double[imagesPerCycle];
            for (int k = 0; k < imagesPerCycle; k++) {
                timeData2[k] = (timeData3[k + (cycle * imagesPerCycle)] - timeData3[cycle * imagesPerCycle]);
            }
            timeData = timeData2;

            final Thread[] threads = newThreadArray();
            //IJ.log("number of threads= " + threads.length);
            final double[][] timeDataArrayOfArrays = new double[threads.length][timeData.length];
            final double[][] pixelsArrayOfArrays = new double[threads.length][timeData.length];

            for (int ithread = 0; ithread < threads.length; ithread++) {
                final int threadIndex = ithread;
                final int cycleNum = cycle;
                final int height = imageH;
                final int width = imageW;
                // Concurrently run in as many threads as CPUs  
                threads[ithread] = new Thread() {
                    {
                        setPriority(Thread.NORM_PRIORITY);
                    }

                    @Override
                    public void run() {
                        for (int y = threadIndex * height / threads.length; y < (threadIndex + 1) * height / threads.length; y++) {
                            if (threadIndex == threads.length - 1) {
                                int startY = threadIndex * height / threads.length;
                                int endY = (threadIndex + 1) * height / threads.length;
                                int progress = (int) Math.round(((double) (y - startY) / (endY - startY)) * 100);
                                IJ.showStatus("Fitting pixels progress: " + progress + " %  of cycle " + (cycleNum + 1) + " of " + numCycles + " total cycles");
                            }
                            for (int x = 0; x < width; x++) {
                                for (int z = 0; z < timeData.length; z++) {
                                    timeDataArrayOfArrays[threadIndex][z] = timeData[z];
                                    if (img.isHyperStack()) {
                                        int z2 = img.getStackIndex(img.getC(), img.getZ(), (cycleNum * imagesPerCycle) + z + 1) - 1;
                                        pixelsArrayOfArrays[threadIndex][z] = img2.getVoxel(x, y, z2);
                                    } else {
                                        pixelsArrayOfArrays[threadIndex][z] = img2.getVoxel(x, y, (cycleNum * imagesPerCycle) + z);
                                    }
                                }
                                pixelsArrayOfArrays[threadIndex]=subtractValueFromArray(pixelsArrayOfArrays[threadIndex], cameraOffset);
                                CurveFitter cf = new CurveFitter(timeDataArrayOfArrays[threadIndex], pixelsArrayOfArrays[threadIndex]);
                                double firstframeint = pixelsArrayOfArrays[threadIndex][0];
                                double lastframeint = pixelsArrayOfArrays[threadIndex][pixelsArrayOfArrays[threadIndex].length - 1];
                                double tau = findTauEstimate(timeDataArrayOfArrays[threadIndex], pixelsArrayOfArrays[threadIndex], firstframeint, lastframeint);
                                
                                if (fitDouble) {
                                    String fitFunction = "y = a*exp(-bx) + c*exp(-dx) + e";
                                    double guess_a1 = (firstframeint - lastframeint) / 2;
                                    double guess_k1 = 1 / tau;
                                    double guess_a2 = (firstframeint - lastframeint) / 2;
                                    double guess_k2 = (1 / tau) / 10;
                                    double guess_o = lastframeint;
                                    double maxiteration = 2000;
                                    double NumRestarts = 2;
                                    double errotTol = 10;
                                    double[] fitparam = {
                                        guess_a1,
                                        guess_k1,
                                        guess_a2,
                                        guess_k2,
                                        guess_o,
                                        maxiteration,
                                        NumRestarts,
                                        errotTol
                                    };
                                    double[] initialParaVara = divideArrayByValue(fitparam, 10);
                                    //UserFunction doubleFit = userFunction(fitparam, timeDataArrayOfArrays[threadIndex]);
                                    //cf.doCustomFit(this, 5, fitFunction, fitparam, initialParaVara, false); //double exponential decay with offset 
                                    double[] fittedParam = cf.getParams();
                                    double R2 = cf.getFitGoodness();
                                    double[] residuals = cf.getResiduals();
                                    double[] theFit = getTheFit(fittedParam, cf.getXPoints());
                                    double Chi2 = calculateReducedChi2(residuals, pixelsArrayOfArrays[threadIndex]);
                                    if (R2 >= R2CutOff && Chi2 < Chi2CutOff) {
                                            aZeroDataG[x][y][cycleNum] = (float) fittedParam[0];
                                            rateDataG[x][y][cycleNum] = (float) fittedParam[1];
                                            a2DataG[x][y][cycleNum] = (float) fittedParam[2];
                                            k2DataG[x][y][cycleNum] = (float) fittedParam[3];
                                            offsetDataG[x][y][cycleNum] = (float) fittedParam[4];
                                            R2G[x][y][cycleNum] = (float) R2;
                                            Chi2G[x][y][cycleNum] = (float) Chi2;
                                        } else {
                                            aZeroDataG[x][y][cycleNum] = 0;
                                            rateDataG[x][y][cycleNum] = 0;
                                            a2DataG[x][y][cycleNum] = 0;
                                            k2DataG[x][y][cycleNum] = 0;
                                            offsetDataG[x][y][cycleNum] = 0;
                                            R2G[x][y][cycleNum] = 0;
                                            Chi2G[x][y][cycleNum] = 0;
                                        }        

                                } else {
                                    double guess_a = firstframeint - lastframeint;
                                    double guess_b = 1 / tau;
                                    double guess_c = lastframeint;
                                    if (guess_a <= 0) {
                                        aZeroDataG[x][y][cycleNum] = 0;
                                        rateDataG[x][y][cycleNum] = 0;
                                        offsetDataG[x][y][cycleNum] = 0;
                                        R2G[x][y][cycleNum] = 0;
                                        Chi2G[x][y][cycleNum] = 0;
                                    } else {
                                        double errotTol = 10;
                                        double[] fitparam = {
                                            guess_a,
                                            guess_b,
                                            guess_c,
                                            maxiteration,
                                            numRestarts,
                                            errotTol
                                        };

                                        cf.setInitialParameters(fitparam);
                                        cf.doFit(11); //exponential decay with offset 
                                        double[] fittedParam = cf.getParams();
                                        double R2 = cf.getFitGoodness();
                                        double[] residuals = cf.getResiduals();
                                        double[] theFit = getTheFit(fittedParam, timeDataArrayOfArrays[threadIndex]);
                                        double Chi2 = calculateReducedChi2(residuals, pixelsArrayOfArrays[threadIndex]);
                                        if (R2 >= R2CutOff && Chi2 < Chi2CutOff) {
                                            aZeroDataG[x][y][cycleNum] = (float) fittedParam[0];
                                            rateDataG[x][y][cycleNum] = (float) fittedParam[1];
                                            offsetDataG[x][y][cycleNum] = (float) fittedParam[2];
                                            R2G[x][y][cycleNum] = (float) R2;
                                            Chi2G[x][y][cycleNum] = (float) Chi2;
                                        } else {
                                            aZeroDataG[x][y][cycleNum] = 0;
                                            rateDataG[x][y][cycleNum] = 0;
                                            offsetDataG[x][y][cycleNum] = 0;
                                            R2G[x][y][cycleNum] = 0;
                                            Chi2G[x][y][cycleNum] = 0;
                                        }
                                    }
                                }
                            }
                        }
                    }
                };
            }
            startAndJoin(threads);
            long timeToCompletion = System.currentTimeMillis() - startTime;
            if (LogFitTime == true) {
                IJ.log("Image " + id + " cycle " + cycle + " processing time = " + (timeToCompletion / 1000) + " sec");
            }
        } //end of cycles  
        rateConstantImage = createRateConstantImage();
    }

    public ImagePlus createRateConstantImage() {
        ImagePlus imp = IJ.createImage("RateConstantsImage", "32-bit", imageW, imageH, numCycles);

        for (int cyc = 0; cyc < numCycles; cyc++) {
            imp.setSlice(cyc + 1);
            ImageProcessor ip = imp.getProcessor();
            FloatProcessor fip = (FloatProcessor) ip.convertToFloat();
            for (int y = 0; y < imageH; y++) {
                for (int x = 0; x < imageW; x++) {
                    if (rateDataG[x][y][cyc] == 0) {
                        fip.setf(x, y, Float.NaN);
                    } else {
                        fip.setf(x, y, (float) rateDataG[x][y][cyc]);
                    }
                }
            }
            IJ.resetMinAndMax(imp);
        }
        imp.show();
        return imp;
    }

    public ImagePlus createOffsetImage() {
        ImagePlus imp = IJ.createImage("OffsetImage", "32-bit", imageW, imageH, numCycles);

        for (int cyc = 0; cyc < numCycles; cyc++) {
            imp.setSlice(cyc + 1);
            ImageProcessor ip = imp.getProcessor();
            FloatProcessor fip = (FloatProcessor) ip.convertToFloat();
            for (int y = 0; y < imageH; y++) {
                for (int x = 0; x < imageW; x++) {
                    if (offsetDataG[x][y][cyc] == 0) {
                        fip.setf(x, y, Float.NaN);
                    } else {
                        fip.setf(x, y, (float) offsetDataG[x][y][cyc]);
                    }
                }
            }
            IJ.resetMinAndMax(imp);
        }
        imp.show();
        return imp;
    }

    public ImagePlus createAZeroImage() {
        ImagePlus imp = IJ.createImage("AZeroImage", "32-bit", imageW, imageH, numCycles);

        for (int cyc = 0; cyc < numCycles; cyc++) {
            imp.setSlice(cyc + 1);
            ImageProcessor ip = imp.getProcessor();
            FloatProcessor fip = (FloatProcessor) ip.convertToFloat();
            for (int y = 0; y < imageH; y++) {
                for (int x = 0; x < imageW; x++) {
                    if (aZeroDataG[x][y][cyc] == 0) {
                        fip.setf(x, y, Float.NaN);
                    } else {
                        fip.setf(x, y, (float) aZeroDataG[x][y][cyc]);
                    }
                }
            }
            IJ.resetMinAndMax(imp);
        }
        imp.show();
        return imp;
    }

    public ImagePlus createChi2Image() {
        ImagePlus imp = IJ.createImage("Chi2Image", "32-bit", imageW, imageH, numCycles);

        for (int cyc = 0; cyc < numCycles; cyc++) {
            imp.setSlice(cyc + 1);
            ImageProcessor ip = imp.getProcessor();
            FloatProcessor fip = (FloatProcessor) ip.convertToFloat();
            for (int y = 0; y < imageH; y++) {
                for (int x = 0; x < imageW; x++) {
                    if (Chi2G[x][y][cyc] == 0) {
                        fip.setf(x, y, Float.NaN);
                    } else {
                        fip.setf(x, y, (float) Chi2G[x][y][cyc]);
                    }
                }
            }
            IJ.resetMinAndMax(imp);
        }
        imp.show();
        return imp;
    }

    public void setUpListeners() {
        String[] imageTitles = WindowManager.getImageTitles();
        listenersRemoved = false;
        ImageWindow win = img.getWindow();
        win.addWindowListener(win);
        canvas = win.getCanvas();
        canvas.addMouseListener(this);

        for (String imageTitle : imageTitles) {
            if (imageTitle.contains("RateConstantsImage")) {
                rateConstantImage = WindowManager.getImage(imageTitle);
                ImageWindow win2 = rateConstantImage.getWindow();
                win2.addWindowListener(win2);
                canvas2 = win2.getCanvas();
                canvas2.addMouseListener(this);
            }
        }

        xAxis = timeData3;
        xLabel = "Time (sec)";
        yLabel = "Fluorescence";
    }

    void positionPlotWindow() {
        IJ.wait(500);
        if (pwin == null || img == null) {
            return;
        }
        ImageWindow iwin = img.getWindow();
        if (iwin == null) {
            return;
        }
        Dimension screen = Toolkit.getDefaultToolkit().getScreenSize();
        Dimension plotSize = pwin.getSize();
        Dimension imageSize = iwin.getSize();
        if (plotSize.width == 0 || imageSize.width == 0) {
            return;
        }
        Point imageLoc = iwin.getLocation();
        int w = imageLoc.x + imageSize.width + 10;
        if (w + plotSize.width > screen.width) {
            w = screen.width - plotSize.width;
        }
        pwin.setLocation(w, imageLoc.y);
        iwin.toFront();
    }

    @Override
    public void mousePressed(MouseEvent e) {
//Gets the pixel values through a single point at (x,y). 

        ImageStack stack = img.getStack();
        int size = stack.getSize();
        double[] values = new double[size];
        xpoint = e.getX();
        ypoint = e.getY();
        float[] cTable = img.getCalibration().getCTable();
        if (img.isHyperStack()) {
            for (int p = 1; p <= img.getNFrames(); p++) {
                int z2 = img.getStackIndex(img.getC(), img.getZ(), p) - 1;
                values[p - 1] = (stack.getVoxel(xpoint, ypoint, z2)-cameraOffset);
            }
        } else {
            for (int p = 1; p <= size; p++) {
                ImageProcessor ip = stack.getProcessor(p);
                ip.setCalibrationTable(cTable);
                values[p - 1] = (ip.getPixelValue(xpoint, ypoint)-cameraOffset);
            }
        }

        img.setRoi(xpoint, ypoint, 1, 1);
        rateConstantImage.setRoi(xpoint, ypoint, 1, 1);
        yAxis = values;
        xAxis = timeData3;
        if (size > numCycles * imagesPerCycle) {
            double[] yAxis2 = new double[numCycles * imagesPerCycle];
            double[] xAxis2 = new double[numCycles * imagesPerCycle];
            for (int i = 0; i < numCycles * imagesPerCycle; i++) {
                yAxis2[i] = yAxis[i];
                xAxis2[i] = xAxis[i];
            }
            yAxis = yAxis2;
            xAxis = xAxis2;
        }
        updateProfile(xAxis, yAxis);

    }

    void updateProfile(double[] x, double[] y) {
        if (!isSelection()) {
            return;
        }
        checkPlotWindow();
        if (listenersRemoved || y == null || y.length == 0) {
            return;
        }
        Plot plot = new Plot("Data and fit", xLabel, yLabel);
        plot.setAxisYLog(yLog);

        plot.add("circles", x, y);
        double[] fitToAdd = new double[x.length];
        double[] yForResiduals = new double[x.length];
        if (rateDataG != null) {
            for (int c = 0; c < numCycles; c++) {
                double[] fitValues = new double[3];
                fitValues[0] = aZeroDataG[xpoint][ypoint][c];
                fitValues[1] = rateDataG[xpoint][ypoint][c];
                fitValues[2] = offsetDataG[xpoint][ypoint][c];
                double[] x2 = new double[imagesPerCycle];
                double[] x4Plot = new double[imagesPerCycle];
                for (int i = 0; i < x2.length; i++) {
                    x2[i] = x[(c * imagesPerCycle) + i] - x[c * imagesPerCycle];
                    x4Plot[i] = x[(c * imagesPerCycle) + i];
                }
                double[] fitPerCycle = getTheFit(fitValues, x2);
                for (int i = 0; i < fitPerCycle.length; i++) {
                    fitToAdd[(c * imagesPerCycle) + i] = fitPerCycle[i];
                    yForResiduals[(c * imagesPerCycle) + i] = y[(c * imagesPerCycle) + i];
                }
                plot.add("line", x4Plot, fitPerCycle);
                String labelToAddA = "A=" + String.valueOf((double) Math.round(fitValues[0] * 1000) / 1000);
                String labelToAddK = "k=" + String.valueOf((double) Math.round(fitValues[1] * 1000) / 1000);
                String labelToAddC = "offset=" + String.valueOf((double) Math.round(fitValues[2] * 1000) / 1000);
                String labelToAddChi2 = "Chi2=" + String.valueOf((double) Math.round(Chi2G[xpoint][ypoint][c] * 1000) / 1000);
                plot.addLabel(c * 0.35 + 0.05, 0.1, labelToAddA);
                plot.addLabel(c * 0.35 + 0.05, 0.15, labelToAddK);
                plot.addLabel(c * 0.35 + 0.05, 0.2, labelToAddC);
                plot.addLabel(c * 0.35 + 0.05, 0.25, labelToAddChi2);
            }
        }

        double ymin = ProfilePlot.getFixedMin();
        double ymax = ProfilePlot.getFixedMax();
        if (!(ymin == 0.0 && ymax == 0.0)) {
            double[] a = Tools.getMinMax(x);
            double xmin = a[0];
            double xmax = a[1];
            plot.setLimits(xmin, xmax, ymin, ymax);
        }
        Plot plotResiduals = new Plot("Residuals", xLabel, yLabel);
        if (rateDataG != null) {
            double[] resArray = subtractArrayFromArray(yForResiduals, fitToAdd);
            plotResiduals.add("circles", x, resArray);
            if (!(ymin == 0.0 && ymax == 0.0)) {
                double[] a = Tools.getMinMax(x);
                double xmin = a[0];
                double xmax = a[1];
                plotResiduals.setLimits(xmin, xmax, ymin, ymax);
            }
        }
        if (pwin == null) {
            pwin = plot.show();
        } else {
            pwin.drawPlot(plot);
        }
        if (rateDataG != null) {
            if (pwin2 == null) {
                pwin2 = plotResiduals.show();
            } else {
                pwin2.drawPlot(plotResiduals);
            }
        }
    }

    // returns false if image is closed
    boolean isSelection() {
        return img != null;
    }

    // stop listening for mouse and key events if the plot window has been closed
    void checkPlotWindow() {
        if (pwin == null) {
            return;
        }
        if (pwin.isVisible()) {
            return;
        }
        ImageWindow iwin = img.getWindow();
        if (iwin == null) {
            return;
        }
        canvas = iwin.getCanvas();
        canvas.removeMouseListener(this);
        ImageWindow iwin2 = rateConstantImage.getWindow();
        if (iwin2 == null) {
            return;
        }
        canvas2 = iwin2.getCanvas();
        canvas2.removeMouseListener(this);
        pwin = null;
        pwin2 = null;
        listenersRemoved = true;
    }

    public void keyPressed(KeyEvent e) {
    }

    public void keyTyped(KeyEvent e) {
    }

    public void mouseReleased(MouseEvent e) {
    }

    public void mouseExited(MouseEvent e) {
    }

    public void mouseClicked(MouseEvent e) {
    }

    public void mouseEntered(MouseEvent e) {
    }

    public void mouseMoved(MouseEvent e) {
    }

    public void mouseDragged(MouseEvent e) {
    }

    public void keyReleased(KeyEvent e) {
    }

    public double findTauEstimate(double[] x, double[] y, double startIntensity, double endIntensity) {
        double tauToReturn = 1;
        double previousIntensity = startIntensity - endIntensity;
        for (int t = 0; t < y.length; t++) {
            if ((y[t] - endIntensity) <= ((startIntensity - endIntensity) * 0.37) && previousIntensity >= ((startIntensity - endIntensity) * 0.37)) {
                tauToReturn = x[t];
            }
            previousIntensity = y[t] - endIntensity;
        }
        return tauToReturn;
    }

    @Override
    public double userFunction(double[] par, double x) {
        if (fitDouble) {
            return par[0] * Math.exp(-par[1] * x) + par[2] * Math.exp(-par[3] * x) + par[4];
        }
        return par[0] * Math.exp(-par[1] * x) + par[2];
    }

    public double[] getTheFit(double[] fitParameters, double[] timePoints) {
        double[] theFit = new double[timePoints.length];
        for (int tp = 0; tp < timePoints.length; tp++) {
            theFit[tp] = fitParameters[0] * Math.exp(-fitParameters[1] * timePoints[tp]) + fitParameters[2];
        }
        return theFit;
    }

    public double calculateChi2(double[] residualArray, double[] theFitArray) {
        double chi2ToReturn = 0;
        double[] residualArray2 = multiplyTwoArrays(residualArray, residualArray);
        double[] arrayToSum = divideTwoArrays(residualArray2, theFitArray);
        for (int tp = 0; tp < arrayToSum.length; tp++) {
            if (!Double.isInfinite(arrayToSum[tp])) {
                chi2ToReturn += arrayToSum[tp];
            }
        }
        return chi2ToReturn;
    }
    
    public double calculateReducedChi2(double[] residualArray, double[] dataArray) {
        double AiryRadius = 1.22*lambda/NA;         
        double PSFArea = Math.PI*AiryRadius*AiryRadius;        
        double numPixelsInPSF = PSFArea/(pixSize*pixSize);
        double chi2ToReturn = 0;
        double weightedAverageVariance = 0;
        double sumWeightedVariance = 0;

        residualArray = multiplyArrayByValue(residualArray,binFactorImage*binFactorImage);//in case of post-processing bin averaging to get total signal
        dataArray = multiplyArrayByValue(dataArray,binFactorImage*binFactorImage);        
        
        residualArray = divideArrayByValue(residualArray,cameraGain);//convert to electrons
        dataArray = divideArrayByValue(dataArray,cameraGain);//convert to electrons; this will also be the uncorrelated variance        
        double[] coVarArray = multiplyArrayByValue(dataArray,binFactor*binFactor/numPixelsInPSF); 
        //if occuring covariance should be within a PSF. The total signal is scaled by the 
        //number of unbinned pixels (number of actual measurements) in a PSF
        //these would be the camera pixels which may have correlated noise
        //this is more of a problem with larger Rois
        dataArray=addTwoArrays(dataArray,coVarArray);//total variance
        
        for(int da=0;da<dataArray.length;da++){
            sumWeightedVariance += (1/dataArray[da]);
        }
        weightedAverageVariance = sumWeightedVariance/dataArray.length;
        double[] weightArray = new double[dataArray.length];
        for(int wa=0;wa<dataArray.length;wa++){
            weightArray[wa] = (1/dataArray[wa])/weightedAverageVariance;
        }
        double[] residualArray2 = multiplyTwoArrays(residualArray, residualArray);
        double[] arrayToSum = multiplyTwoArrays(residualArray2, weightArray);
        for (int tp = 0; tp < arrayToSum.length; tp++) {
            if (!Double.isInfinite(arrayToSum[tp])) {               
                chi2ToReturn += arrayToSum[tp];
            }
        }
        int df;
        if(fitDouble)
            df=6;
        else
            df=4;
        return (chi2ToReturn/(residualArray.length-df))*weightedAverageVariance;
    }

    /**
     * Create a Thread[] array as large as the number of processors available.
     * From Stephan Preibisch's Multithreading.java class. See:
     * http://repo.or.cz/w/trakem2.git?a=blob;f=mpi/fruitfly/general/MultiThreading.java;hb=HEAD
     */
    private Thread[] newThreadArray() {
        int n_cpus = Runtime.getRuntime().availableProcessors();
        return new Thread[n_cpus];
    }

    /**
     * Start all given threads and wait on each of them until all are done. From
     * Stephan Preibisch's Multithreading.java class. See:
     * http://repo.or.cz/w/trakem2.git?a=blob;f=mpi/fruitfly/general/MultiThreading.java;hb=HEAD
     *
     * @param threads
     */
    public static void startAndJoin(Thread[] threads) {
        for (int ithread = 0; ithread < threads.length; ++ithread) {
            threads[ithread].setPriority(Thread.NORM_PRIORITY);
            threads[ithread].start();
        }

        try {
            for (int ithread = 0; ithread < threads.length; ++ithread) {
                threads[ithread].join();
            }
        } catch (InterruptedException ie) {
            throw new RuntimeException(ie);
        }
    }

    public double[] getArrayStatistics(double[] theArray) {

        double min = theArray[0];
        double max = theArray[0];
        double sum = 0;
        for (int i = 0; i < theArray.length; i++) {
            if (theArray[i] < min) {
                min = theArray[i];
            }
            if (theArray[i] > max) {
                max = theArray[i];
            }
            sum = sum + theArray[i];
        }
        double mean = sum / theArray.length;
        double[] returnArray = {min, max, sum, mean};
        return returnArray;
    }

    private double[] getTimingPerPlane(String arg, int tPoints, int currZ, int currCh) throws Exception {
        String fExt = arg.substring(arg.indexOf("."), arg.length());
        if (fExt.contains(" ") && fExt.indexOf(" ") < arg.length()) {
            fExt = fExt.substring(0, fExt.indexOf(" "));
        }
        String id2 = arg.substring(0, arg.indexOf(".")) + fExt;
        double[] timeStampsToReturn = new double[tPoints];
        IFormatReader reader = null;
        int series = 0;
        try {
            ServiceFactory factory = new ServiceFactory();
            OMEXMLService service = factory.getInstance(OMEXMLService.class);
            IMetadata meta = service.createOMEXMLMetadata();
            // create format reader
            reader = new ImageReader();
            reader.setMetadataStore(meta);
            // initialize file
            reader.setId(id2);

            int seriesCount = reader.getSeriesCount();

            if (series < seriesCount) {
                reader.setSeries(series);
            }
            series = reader.getSeries();
            int planeCount = meta.getPlaneCount(series);
            int tCounter = 0;
            for (int i = 0; i < planeCount; i++) {
                Time deltaT = meta.getPlaneDeltaT(series, i);
                if (deltaT == null) {
                    continue;
                }
                // convert plane ZCT coordinates into image plane index
                int z = meta.getPlaneTheZ(series, i).getValue();
                int c = meta.getPlaneTheC(series, i).getValue();
                int t = meta.getPlaneTheT(series, i).getValue();
                if (z == currZ && c == currCh) {
                    timeStampsToReturn[tCounter] = deltaT.value(UNITS.SECOND).doubleValue();
                    tCounter++;
                }
            }
            if (planeCount == 0) {
                GenericDialog gd2 = new GenericDialog("Problem with metadata");
                gd2.addMessage("Time information from metadata was not found");
                gd2.addMessage("Would you like to enter the time interval manually?");
                gd2.addNumericField("Time between images in seconds", 0.050, 3);
                gd2.showDialog();
                if (gd2.wasCanceled()) {
                    return null;
                }
                double userDeltaT = gd2.getNextNumber();
                for (int t = 0; t < timeStampsToReturn.length; t++) {
                    timeStampsToReturn[t] = t * userDeltaT;
                }
            }
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            try {
                if (reader != null) {
                    reader.close();
                }
            } catch (IOException ex) {
                ex.printStackTrace();
            }
        }
        return timeStampsToReturn;
    }

    private static double[] subtractArrayFromArray(double[] array1, double[] array2) {
        if (array1.length != array2.length) {
            IJ.showMessage("Pixel Fitter", "The time and data arrays are not the same length");
            return null;
        }
        double[] arrayToReturn = new double[array1.length];
        for (int i = 0; i < array1.length; i++) {
            arrayToReturn[i] = array1[i] - array2[i];
        }
        return arrayToReturn;

    }

    private static double[] multiplyTwoArrays(double[] array1, double[] array2) {
        if (array1.length != array2.length) {
            IJ.showMessage("Pixel Fitter", "The time and data arrays are not the same length");
            return null;
        }
        double[] arrayToReturn = new double[array1.length];
        for (int i = 0; i < array1.length; i++) {
            arrayToReturn[i] = array1[i] * array2[i];
        }
        return arrayToReturn;
    }

    private static double[] divideTwoArrays(double[] array1, double[] array2) {
        if (array1.length != array2.length) {
            IJ.showMessage("Pixel Fitter", "The time and data arrays are not the same length");
            return null;
        }
        double[] arrayToReturn = new double[array1.length];
        for (int i = 0; i < array1.length; i++) {
            arrayToReturn[i] = array1[i] / array2[i];
        }
        return arrayToReturn;
    }

    private static double[] subtractValueFromArray(double[] array1, double theValue) {
        double[] arrayToReturn = new double[array1.length];
        for (int i = 0; i < array1.length; i++) {
            arrayToReturn[i] = array1[i] - theValue;
        }
        return arrayToReturn;
    }

    private static double[] divideArrayByValue(double[] array1, double theValue) {
        double[] arrayToReturn = new double[array1.length];
        for (int i = 0; i < array1.length; i++) {
            arrayToReturn[i] = array1[i] / theValue;
        }
        return arrayToReturn;
    }
    
    public static double getMeanOfArray(double[] theArray) {
        double sum = 0;
        for (int i = 0; i < theArray.length; i++) {
            sum = sum + theArray[i];
        }
        return sum / theArray.length;
    }

    public static double getSumOfArray(double[] theArray) {
        double sum = 0;
        for (int i = 0; i < theArray.length; i++) {
            sum = sum + theArray[i];
        }
        return sum;
    }
     private static double[] multiplyArrayByValue(double[] array1, double theValue) {
        double[] arrayToReturn = new double[array1.length];
        for (int i = 0; i < array1.length; i++) {
            arrayToReturn[i] = array1[i]*theValue;
        }
        return arrayToReturn;
    }
     private static double[] addTwoArrays(double[] array1, double[] array2) {
        if (array1.length != array2.length) {
            IJ.showMessage("psFRET_T_Profiler", "The time and data arrays are not the same length");
            return null;
        }
        double[] arrayToReturn = new double[array1.length];
        for (int i = 0; i < array1.length; i++) {
            arrayToReturn[i] = array1[i] + array2[i];
        }
        return arrayToReturn;

    }
  
    
}
